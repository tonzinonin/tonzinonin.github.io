<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>final fantasy | final fantasy</title><meta name="author" content="某不知名的作者"><meta name="copyright" content="某不知名的作者"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="UnityShaderGraphYoutube教程UnityShaderGraphBasics 创建首先我们创建一个universal render pipeline的项目 进入项目，我们可以在package Manager当中查看Shader Graph插件是否已经正常安装 之后  我们在资源管理面板当中选择符合自己项目渲染管线的shader Graph  双击之后，unity就会打开这个sha">
<meta property="og:type" content="article">
<meta property="og:title" content="final fantasy">
<meta property="og:url" content="https://tonzinonin.github.io/2025/03/26/UnityShaderGraph/index.html">
<meta property="og:site_name" content="final fantasy">
<meta property="og:description" content="UnityShaderGraphYoutube教程UnityShaderGraphBasics 创建首先我们创建一个universal render pipeline的项目 进入项目，我们可以在package Manager当中查看Shader Graph插件是否已经正常安装 之后  我们在资源管理面板当中选择符合自己项目渲染管线的shader Graph  双击之后，unity就会打开这个sha">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg">
<meta property="article:published_time" content="2025-03-26T08:33:02.619Z">
<meta property="article:modified_time" content="2025-03-27T16:26:38.396Z">
<meta property="article:author" content="某不知名的作者">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg"><link rel="shortcut icon" href="/img/icon.png"><link rel="canonical" href="https://tonzinonin.github.io/2025/03/26/UnityShaderGraph/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'final fantasy',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-28 00:26:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/OIP.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">final fantasy</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-26T08:33:02.619Z" title="发表于 2025-03-26 16:33:02">2025-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-27T16:26:38.396Z" title="更新于 2025-03-28 00:26:38">2025-03-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="UnityShaderGraph"><a href="#UnityShaderGraph" class="headerlink" title="UnityShaderGraph"></a>UnityShaderGraph</h1><p>Youtube教程UnityShaderGraphBasics</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>首先我们创建一个universal render pipeline的项目</p>
<p>进入项目，我们可以在package Manager当中查看Shader Graph插件是否已经正常安装</p>
<p>之后</p>
<p><img src="/./../../../BlogImg/image-20250326173931136.png" alt="image-20250326173931136"></p>
<p>我们在资源管理面板当中选择符合自己项目渲染管线的shader Graph</p>
<p><img src="/./../../../BlogImg/image-20250326174447831.png" alt="image-20250326174447831"></p>
<p>双击之后，unity就会打开这个shader graph</p>
<p>之后你可以调整fragment片元着色器输出的颜色</p>
<p><img src="/./../../../BlogImg/image-20250326174730722.png" alt="image-20250326174730722"></p>
<p>获取挂载了这个shadergraph的材质</p>
<p><img src="/./../../../BlogImg/image-20250326174930174.png" alt="image-20250326174930174"></p>
<p>在shadergraph里面创建属性</p>
<p><img src="/./../../../BlogImg/image-20250326175035393.png" alt="image-20250326175035393"></p>
<p><img src="/./../../../BlogImg/image-20250326175223926.png" alt="image-20250326175223926"></p>
<p><img src="/./../../../BlogImg/image-20250326175625340.png" alt="image-20250326175625340"></p>
<p>调整颜色之后赋值到场景中的物体上</p>
<p><img src="/./../../../BlogImg/image-20250326181453712.png" alt="image-20250326181453712"></p>
<h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>右键或者空格快速创建节点</p>
<p><img src="/./../../../BlogImg/image-20250326180609272.png" alt="image-20250326180609272"></p>
<p><img src="/./../../../BlogImg/image-20250326180657196.png" alt="image-20250326180657196"></p>
<p>创建了之后，我们把我们创建的texture属性连接上sampleTexture2D，一般来说，unity会自动在内存空间当中帮我们申明一段uv（也就是uv0）</p>
<p>之后我们将颜色和纹理的rgb值进行相乘</p>
<p><img src="/./../../../BlogImg/image-20250326180921267.png" alt="image-20250326180921267"></p>
<p>注意：<br><img src="/./../../../BlogImg/image-20250326183803781.png" alt="image-20250326183803781"></p>
<p><img src="/./../../../BlogImg/image-20250326184109623.png" alt="image-20250326184109623"></p>
<p>制作简单的uv动画</p>
<p><img src="/./../../../BlogImg/image-20250326181103954.png" alt="image-20250326181103954"><br>我们创建了一个scrollvelocity属性</p>
<p><img src="/./../../../BlogImg/image-20250326184454269.png" alt="image-20250326184454269"><br>之后创建time节点和multiply节点</p>
<p><img src="/./../../../BlogImg/image-20250326184554948.png" alt="image-20250326184554948"><br>这个结点可以计算uv的偏移</p>
<p><img src="/./../../../BlogImg/image-20250326184846935.png" alt="image-20250326184846935"></p>
<h2 id="透明"><a href="#透明" class="headerlink" title="透明"></a>透明</h2><p><img src="/./../../../BlogImg/image-20250326185831125.png" alt="image-20250326185831125"></p>
<p>queue值更低的物体绘制顺序更加靠前。一般来说透明物体距离摄像机越远它的queue值会越大，也就是越远的物体越先进行绘制，这样会牺牲一定的性能</p>
<p>要把透明物体的深度写入关闭，并且保证不透明物体是先进行绘制的，防止有物体读取到透明物体的深度值然后发生剔除</p>
<p>Shadergraph会自动替我们为透明物体设置渲染队列</p>
<p><img src="/./../../../BlogImg/image-20250326190816753.png" alt="image-20250326190816753"></p>
<p>在graphsetting里面将物体的surfaceType设置成透明</p>
<p><img src="/./../../../BlogImg/image-20250326191156630.png" alt="image-20250326191156630"></p>
<p>之后我们就可以得到alpha混合的效果</p>
<p><img src="/./../../../BlogImg/image-20250326191442699.png" alt="image-20250326191442699"></p>
<p>alpha clipping可以将不透明度低于某一个值的片元直接进行裁剪</p>
<p>首先我们要在Graph Setting调整Surface Type为Opaque，并且勾选alpha clipping</p>
<p><img src="/./../../../BlogImg/image-20250326191756744.png" alt="image-20250326191756744"></p>
<p><img src="/./../../../BlogImg/image-20250326191828841.png" alt="image-20250326191828841"><br><img src="/./../../../BlogImg/image-20250326191912852.png" alt="image-20250326191912852"></p>
<p>如图我们将一个png图片（这个图片中间透明度最低（alpha高），两边透明度最高（alpha低），以圆的方向扩散开），可以看到alpha值小于0.5的都被剔除了</p>
<p><img src="/./../../../BlogImg/image-20250326192137685.png" alt="image-20250326192137685"></p>
<p>之后我们创建一个threshold属性然后连接alpha clip threshold，之后将这个属性mode设置成slider滑块，然后我们就可以在inspector当中调整透明剪切的程度</p>
<p>使用alpha裁剪的不透明物体有剔除像素的能力但是太暴力了</p>
<p>我们可以使用一种叫做dithering的技术来伪造透明度</p>
<p><img src="/./../../../BlogImg/image-20250326192509823.png" alt="image-20250326192509823"></p>
<p>shadergraph中创建dither</p>
<p><img src="/./../../../BlogImg/image-20250326192759659.png" alt="image-20250326192759659"></p>
<p>将x设置成1<br><img src="/./../../../BlogImg/image-20250326192836903.png" alt="image-20250326192836903"></p>
<p><img src="/./../../../BlogImg/image-20250326192850264.png" alt="image-20250326192850264"></p>
<p>之后我们就可以在界面来调整了</p>
<p><img src="/./../../../BlogImg/image-20250326192945336.png" alt="image-20250326192945336"></p>
<h2 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h2><p><img src="/./../../../BlogImg/image-20250326193624193.png" alt="image-20250326193624193"></p>
<p><strong>Auto</strong>代表对不透明物体进行深度写入，对透明物体不进行深度写入</p>
<p><strong>ForceEnabled</strong>代表强行对所有的物体进行深度写入</p>
<p><strong>ForceDisabled</strong>代表不对透明物体进行深度写入</p>
<p><strong>Depth Test</strong></p>
<p><img src="/./../../../BlogImg/image-20250326193924111.png" alt="image-20250326193924111"></p>
<p>它决定了深度值的比较方式和是否写入像素值</p>
<p><strong>LEqual</strong>代表了如果物体更近那么就pass</p>
<p><img src="/./../../../BlogImg/image-20250326194150451.png" alt="image-20250326194150451"></p>
<p><strong>always</strong>代表不论深度缓冲区中的值是多少这个物体总是会被绘制</p>
<p><img src="/./../../../BlogImg/image-20250326194136441.png" alt="image-20250326194136441"></p>
<p><strong>Never</strong>代表任何时候深度缓冲区的比较都会失败</p>
<p><img src="/./../../../BlogImg/image-20250326194257935.png" alt="image-20250326194257935"></p>
<p><strong>Greater</strong>代表只有当这个物体前面有更近的物体（更小的深度值）这个物体才会被绘制</p>
<p><img src="/./../../../BlogImg/image-20250326194527810.png" alt="image-20250326194527810"></p>
<p><img src="/./../../../BlogImg/image-20250326194613415.png" alt="image-20250326194613415"></p>
<p>这个按钮可以让你在inspector窗口当中modify这些depth setting</p>
<p>我们的shader一般不能直接对depth buffer中的值进行读取，而是在所有的物体都被绘制之后</p>
<p><img src="/./../../../BlogImg/image-20250326194841115.png" alt="image-20250326194841115"></p>
<p>unity会将这个这一帧的深度值buffer的状态保存为一个摄像机深度纹理</p>
<p>我们shader可以获取这个深度纹理</p>
<p>注意</p>
<p>这个纹理只会包含有用的信息如果我们在写一个透明的shader</p>
<p>这个纹理不会包含有关透明物体的深度值</p>
<p><strong>在URP当中使用这个纹理</strong></p>
<p>我们需要激活它</p>
<p>第一步：找到你的项目使用的URP assets。如果你使用的URp模板创建的项目，那么这个资源在Assets&#x2F;Settings</p>
<p><img src="/./../../../BlogImg/image-20250326195538515.png" alt="image-20250326195538515"></p>
<p>选择其中的每一个并且将其的DepthTexture勾选上</p>
<p>之后我们创建一个新的ShaderGraph</p>
<p>第一步我们需要将Graph Settings里面的Surface Type选择上Transparent</p>
<p>之后我们需要添加新的颜色属性：前色和背景色</p>
<p><img src="/./../../../BlogImg/image-20250326195828907.png" alt="image-20250326195828907"></p>
<p>创建一个叫做scenedepth的node</p>
<p><img src="/./../../../BlogImg/image-20250326195900168.png" alt="image-20250326195900168"></p>
<p><img src="/./../../../BlogImg/image-20250326195959354.png" alt="image-20250326195959354"></p>
<p>之后将模式选择成raw，这个时候我们就可以获取depth values了</p>
<p><img src="/./../../../BlogImg/image-20250326200155296.png" alt="image-20250326200155296"></p>
<p>如果我们调整成<strong>Linear01</strong></p>
<p>那么depth value就会线性化</p>
<p>他和raw value一样都在0和1之间，但是通过映射得到了相反的效果</p>
<p>在 Unity 的渲染管线（如 URP、HDRP）中，Z-Buffer 存储的深度值通常是 <strong>非线性的</strong>（透视投影下）。使用 <code>Linear01</code> 可以将这些深度值转换为 <strong>线性 0~1 之间的数值</strong>，使其更适合用于后处理计算（如景深、雾效）。</p>
<p><img src="/./../../../BlogImg/image-20250326200558400.png" alt="image-20250326200558400"></p>
<p><img src="/./../../../BlogImg/image-20250326200627299.png" alt="image-20250326200627299"></p>
<p>相机深度值代表的是从相机到物体的真实距离，以世界单位来衡量（Unity的米），而不是0~1归一化的深度值</p>
<p>在eye模式下，近平面near-&gt;深度值接近0</p>
<p>远平面深度值变大（单位是米）</p>
<p><img src="/./../../../BlogImg/image-20250326201117203.png" alt="image-20250326201117203"></p>
<p><img src="/./../../../BlogImg/image-20250326201134353.png" alt="image-20250326201134353"></p>
<p>Lerp节点与math中的lerp类似，在两个值之间依靠一个0~1的比例值进行线性变化<br><img src="/./../../../BlogImg/image-20250326201302719.png" alt="image-20250326201302719"></p>
<p><img src="/./../../../BlogImg/image-20250326201428536.png" alt="image-20250326201428536"></p>
<p>之后我们可以在场景当中调整深度图的颜色，获得一些渐变效果</p>
<p>之后可以把材质拖拽到物体上</p>
<p><img src="/./../../../BlogImg/image-20250326201512011.png" alt="image-20250326201512011"></p>
<p>之后让摄像机对着这个物体，我们可以看到这个物体后面显示了深度值（被设置成了线性的粉色）</p>
<p><img src="/./../../../BlogImg/image-20250326201557380.png" alt="image-20250326201557380"></p>
<h2 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h2><p>我们创建两个值来模拟顶点动画</p>
<p><img src="/./../../../BlogImg/image-20250326202936764.png" alt="image-20250326202936764"></p>
<p>我们将会让顶点根据sin值上下浮动，其中speed代表速度（频率），strength代表幅度</p>
<p>但是如果仅仅是这样，我们只会让全部的顶点根据正弦函数上下移动，而模拟不出我们需要的波浪效果</p>
<p>我们可以将顶点在世界空间当中的坐标作为offset偏移值来模拟波浪效果</p>
<p><img src="/./../../../BlogImg/image-20250326203210457.png" alt="image-20250326203210457"></p>
<p><img src="/./../../../BlogImg/image-20250326203239883.png" alt="image-20250326203239883"></p>
<p>你也可以使用模型空间，但是在世界空间下，它们可以更好地合并在一起，如上图所示</p>
<p><img src="/./../../../BlogImg/image-20250326210131340.png" alt="image-20250326210131340"></p>
<p><img src="/./../../../BlogImg/image-20250326210204342.png" alt="image-20250326210204342"></p>
<p><strong>tessellation（曲面细分）</strong></p>
<p>URP Shader Graph貌似不支持tessellation</p>
<p><img src="/./../../../BlogImg/image-20250326210531810.png" alt="image-20250326210531810"></p>
<p><img src="/./../../../BlogImg/image-20250326210545296.png" alt="image-20250326210545296"></p>
<p><img src="/./../../../BlogImg/image-20250326210629878.png" alt="image-20250326210629878"></p>
<p><img src="/./../../../BlogImg/image-20250326210656911.png" alt="image-20250326210656911"><br>hdrp是camera relative rendering，所以是绝对世界坐标</p>
<p><img src="/./../../../BlogImg/image-20250326210820654.png" alt="image-20250326210820654"></p>
<p><img src="/./../../../BlogImg/image-20250326210836794.png" alt="image-20250326210836794"></p>
<p><img src="/./../../../BlogImg/image-20250326210926307.png" alt="image-20250326210926307"></p>
<p>之后通过更改x的值，附上材质的物体将会添加曲面细分</p>
<p><img src="/./../../../BlogImg/image-20250326211017867.png" alt="image-20250326211017867"></p>
<h2 id="灯"><a href="#灯" class="headerlink" title="灯"></a>灯</h2><p>与之前创建unlit shader graph不一样，这次我们创建了一个lit shader graph</p>
<p><img src="/./../../../BlogImg/image-20250326211536605.png" alt="image-20250326211536605"></p>
<p>我们找到一个具有许多附加纹理的纹理</p>
<p><img src="/./../../../BlogImg/image-20250326212447980.png" alt="image-20250326212447980"></p>
<p>依次是反射颜色贴图，粗糙度贴图，环境光遮罩贴图，位移贴图，法线贴图</p>
<p><strong>高度贴图</strong></p>
<p><img src="/./../../../BlogImg/image-20250326213045530.png" alt="image-20250326213045530"></p>
<p>连接到一起</p>
<p><img src="/./../../../BlogImg/image-20250326213121386.png" alt="image-20250326213121386"></p>
<p><strong>法线贴图</strong></p>
<p><img src="/./../../../BlogImg/image-20250326213509127.png" alt="image-20250326213509127"></p>
<p><strong>金属</strong></p>
<p><img src="/./../../../BlogImg/image-20250326213605871.png" alt="image-20250326213605871"></p>
<p>可以看到在Graph inspector当中，这里有两种工作流，Specular和Metallic</p>
<p><img src="/./../../../BlogImg/image-20250326213919035.png" alt="image-20250326213919035"></p>
<p>两者的区别在于</p>
<p><img src="/./../../../BlogImg/image-20250326214203858.png" alt="image-20250326214203858"></p>
<p>创建一个名为Metallic的属性</p>
<p><img src="/./../../../BlogImg/image-20250326214311959.png" alt="image-20250326214311959"><br><img src="/./../../../BlogImg/image-20250326214325954.png" alt="image-20250326214325954"></p>
<p>连接到fragment上面</p>
<p><strong>粗糙度贴图</strong></p>
<p><img src="/./../../../BlogImg/image-20250326214551723.png" alt="image-20250326214551723"></p>
<p><img src="/./../../../BlogImg/image-20250326215039822.png" alt="image-20250326215039822"></p>
<p><strong>自发光</strong></p>
<p>添加一个叫做emmision color的vector4</p>
<p><img src="/./../../../BlogImg/image-20250326215121510.png" alt="image-20250326215121510"></p>
<p>将其设置成HDR</p>
<p><img src="/./../../../BlogImg/image-20250326215135885.png" alt="image-20250326215135885"></p>
<p>这允许我们使用更高密度超出通常选色范围的颜色</p>
<p><img src="/./../../../BlogImg/image-20250326215259322.png" alt="image-20250326215259322"></p>
<p>一般来说你需要通过bloom后处理效果才能得到自发光物体的泛光现象</p>
<p><img src="/./../../../BlogImg/image-20250326215433240.png" alt="image-20250326215433240"></p>
<p>但是拥有URP的项目可以直接调用bloom</p>
<p><img src="/./../../../BlogImg/image-20250326215510722.png" alt="image-20250326215510722"></p>
<p>之后我们会在Hierarchy面板当中看到新建了一个Global Volume物体</p>
<p><img src="/./../../../BlogImg/image-20250326215618708.png" alt="image-20250326215618708"></p>
<p>之后我们可以添加override来得到更多的后处理效果</p>
<p><img src="/./../../../BlogImg/image-20250326215644853.png" alt="image-20250326215644853"></p>
<p><img src="/./../../../BlogImg/image-20250326215816574.png" alt="image-20250326215816574"></p>
<p><strong>环境光遮蔽</strong></p>
<p>有时候我们不需要整个物体都拥有高光效果，比如说这个物体上有一些泥巴或者坑坑洼洼的小洞，那么相对于金属表面来说这些地方的反射强度就会弱一些</p>
<p><img src="/./../../../BlogImg/image-20250326220101087.png" alt="image-20250326220101087"></p>
<p><img src="/./../../../BlogImg/image-20250326220439038.png" alt="image-20250326220439038"></p>
<p>最终结果</p>
<p><img src="/./../../../BlogImg/image-20250326220928800.png" alt="image-20250326220928800"></p>
<h2 id="更多灯"><a href="#更多灯" class="headerlink" title="更多灯"></a>更多灯</h2><p><strong>菲涅耳反射</strong></p>
<p>它事实上是一种类型的镜面反射</p>
<p><img src="/./../../../BlogImg/image-20250326221312021.png" alt="image-20250326221312021"></p>
<p>主要是这个power可以控制菲涅耳反射的力度</p>
<p><strong>使用菲涅耳反射模拟物体高亮</strong></p>
<p>添加属性，用来控制菲涅耳反射强度</p>
<p><img src="/./../../../BlogImg/image-20250326222220127.png" alt="image-20250326222220127"></p>
<p>添加菲涅耳颜色。并且设置成HDR</p>
<p><img src="/./../../../BlogImg/image-20250326222316930.png" alt="image-20250326222316930"></p>
<p><img src="/./../../../BlogImg/image-20250326222330341.png" alt="image-20250326222330341"></p>
<p>注意这个intensity实际上是指数，pow（color，intensity），所以当intensity为0的时候即没有HDR</p>
<p><img src="/./../../../BlogImg/image-20250326222742176.png" alt="image-20250326222742176"></p>
<p>有时候这下面只是一些非常相似的颜色，这事实上并不是bug，而是intensity太高的缘故</p>
<p><img src="/./../../../BlogImg/image-20250326222453227.png" alt="image-20250326222453227"></p>
<p><img src="/./../../../BlogImg/image-20250326222955109.png" alt="image-20250326222955109"></p>
<p><img src="/./../../../BlogImg/image-20250326223151784.png" alt="image-20250326223151784"></p>
<p>因为硬边立方体的法线布置比较失真，所以效果不太好</p>
<p><img src="/./../../../BlogImg/image-20250326223258883.png" alt="image-20250326223258883"></p>
<p>球体的效果</p>
<h2 id="NPR"><a href="#NPR" class="headerlink" title="NPR"></a>NPR</h2><p>一般来说，不使用lit shadergraph来模拟非真实感的效果，因为lit的可操作性太低</p>
<p>一般使用unlit来模拟npr</p>
<p><img src="/./../../../BlogImg/image-20250326230513524.png" alt="image-20250326230513524"></p>
<p>接下来是对卡通渲染来说至关重要的阈值阶段</p>
<p>有两种方法来处理</p>
<p>第一种涉及到Step节点</p>
<p><img src="/./../../../BlogImg/image-20250326230657262.png" alt="image-20250326230657262"></p>
<p>否则输出1或者白色，在数学中这被称为阶跃函数</p>
<p>而smoothStep，中间会有一层缓冲区</p>
<p><img src="/./../../../BlogImg/image-20250326230822397.png" alt="image-20250326230822397"></p>
<p><img src="/./../../../BlogImg/image-20250326232428043.png" alt="image-20250326232428043"></p>
<p>smoothstep模拟npr光照</p>
<p><img src="/./../../../BlogImg/image-20250326232618690.png" alt="image-20250326232618690"></p>
<p>这个ambient light strength是一个浮点值</p>
<p>之后我们就可以在inspector面板里面进行光照调整了</p>
<h2 id="场景交叉的环境光遮蔽"><a href="#场景交叉的环境光遮蔽" class="headerlink" title="场景交叉的环境光遮蔽"></a>场景交叉的环境光遮蔽</h2><p>更多的环境光遮蔽</p>
<p>我们在现实生活当中，会发现当两个物体相交的时候，这两个物体之间存在阴影</p>
<p>如何检测交叉点</p>
<p>当shader正在运行的时候，它只能访问有关当前正在渲染的像素的信息。</p>
<p>包括其在世界空间当中的位置，我们希望将该位置与其后面渲染的下一个对象的位置进行比较</p>
<p><img src="/./../../../BlogImg/image-20250326233542875.png" alt="image-20250326233542875"></p>
<p>如果两点之间的距离小于我们给定的阈值，那么就说明我们检测到了交点</p>
<p><img src="/./../../../BlogImg/image-20250326233616013.png" alt="image-20250326233616013"></p>
<p>这确实带来了一些限制</p>
<p>首先我们的交叉着色器必须是透明的，因为unity仅在渲染所有不透明物体之后和渲染所有透明物体之前，将深度缓冲区的状态保存到深度纹理当中，其次，出于同样的原因，我们的着色器将会无法检测任何两个透明物体之间的交点</p>
<p><img src="/./../../../BlogImg/image-20250326234123851.png" alt="image-20250326234123851"></p>
<p><strong>获取相机到地板的距离</strong></p>
<p>由于地板是有深度值的，我们将会使用场景深度节点来获取相机与之前在此处渲染的对象之间的距离</p>
<p><img src="/./../../../BlogImg/image-20250326235214700.png" alt="image-20250326235214700"></p>
<p>注意要将Samplin设置成Eye模式，精确地获取到这个距离</p>
<p><strong>获取相机到物体表面的距离</strong></p>
<p>由于物体设置的是Transparent模式，它的深度没有进行写入，所以我们需要使用一些特殊的处理方法</p>
<p>回顾一下裁剪空间的概念</p>
<p>在裁剪空间当中这个w值的意义是相机和正在渲染的顶点之间的距离</p>
<p><img src="/./../../../BlogImg/image-20250326234623859.png" alt="image-20250326234623859"></p>
<p>透视除法之后的z&#x2F;w才是深度值</p>
<p><img src="/./../../../BlogImg/image-20250326234806230.png" alt="image-20250326234806230"></p>
<p><img src="/./../../../BlogImg/image-20250326234956399.png" alt="image-20250326234956399"></p>
<p>之后我们得到了照射到floor的距离（蓝色），以及到物体表面的距离（橙色）</p>
<p><img src="/./../../../BlogImg/image-20250326235511523.png" alt="image-20250326235511523"></p>
<p>之后我们将其详见获取器紫色部分的值</p>
<h3 id="shader使用技巧复制粘贴"><a href="#shader使用技巧复制粘贴" class="headerlink" title="shader使用技巧复制粘贴"></a>shader使用技巧复制粘贴</h3><p>使用子图来进行重用节点</p>
<p><img src="/./../../../BlogImg/image-20250326235819924.png" alt="image-20250326235819924"></p>
<p>选中这些节点右键</p>
<p><img src="/./../../../BlogImg/image-20250326235859785.png" alt="image-20250326235859785"></p>
<p>之后我们可以将它保存在任何我们想要的地方</p>
<p>之后我们可以在project view当中双击进入subgraph进行编辑</p>
<p><img src="/./../../../BlogImg/image-20250327000251565.png" alt="image-20250327000251565"></p>
<p>可以看到它必须要一个输出不然就会报错</p>
<p>这个子图默认不需要输入，但是我们仍然可以像常规图添加属性一样来添加输入</p>
<p><img src="/./../../../BlogImg/image-20250327000447213.png" alt="image-20250327000447213"><br>点击此处将新的输出添加到列表当中</p>
<p>该子图的唯一输出僵尸表示交叉点长度的距离值</p>
<p>该子图的唯一输出将会是表示交叉点长度的距离值，于是我们可以添加一个float类型的输出</p>
<p>回到我们的shadergraph</p>
<p>注意要将Surface Type选择为Transparent</p>
<p><img src="/./../../../BlogImg/image-20250327000851304.png" alt="image-20250327000851304"></p>
<p>如果我们将这个函数连接到basecolor，球体网格看起来边缘会是黑色的</p>
<p><img src="/./../../../BlogImg/image-20250327001000225.png" alt="image-20250327001000225"></p>
<p>因为在靠近地面的地方，距离值几乎为0，这个时候差不多就是黑色，上面的部分没有交点，几乎就是白色</p>
<p>相反。我们想将其转换为一个值，其中1代表交叉点的全部强度，并且当我们距离交叉点越来越远的时候，它会变得越来越低</p>
<p>这个时候我们就会使用One minus，但是有时候这会变成负数，因为白色部分有很多地方都是与背面物体的距离大于1的。</p>
<p>所以我们会使用到saturate</p>
<p><img src="/./../../../BlogImg/image-20250327001641851.png" alt="image-20250327001641851"></p>
<p>接下来我们需要控制交叉口的宽度</p>
<p>有很多的方法可以做到这一点，但是目前我们处理的是0 到 1之间的值</p>
<p>所以最简单的方法可能是将之提升到可以配置的Power Value（指数值）</p>
<p><img src="/./../../../BlogImg/image-20250327002016623.png" alt="image-20250327002016623"></p>
<p><img src="/./../../../BlogImg/image-20250327002041603.png" alt="image-20250327002041603"></p>
<p>其中0会将完全遮挡应用于整个网格，而25是一个任意值，会导致非常薄的遮挡</p>
<p><img src="/./../../../BlogImg/image-20250327002207129.png" alt="image-20250327002207129"></p>
<p><img src="/./../../../BlogImg/image-20250327002232833.png" alt="image-20250327002232833"></p>
<p>这个浮点属性来添加使遮挡整体变亮或者变暗的功能</p>
<p>这个可以是0到1之间的滑块</p>
<p>它将会作为我们迄今为止计算的值的全局乘数</p>
<p><img src="/./../../../BlogImg/image-20250327002441670.png" alt="image-20250327002441670"></p>
<p>到目前为止，我们仍然有一个0到1之间遮挡强度的值，其中0代表没有遮挡，1代表遮挡程度最高</p>
<p>由于各种浮点运算，这个值将会难以达到1</p>
<p><img src="/./../../../BlogImg/image-20250327002739893.png" alt="image-20250327002739893"></p>
<p>之后我们可以在inspector窗口当中调整边缘环境光遮蔽的强度</p>
<p><img src="/./../../../BlogImg/image-20250327002805172.png" alt="image-20250327002805172"></p>
<p>我们可以通过这种效果来软化岩石与地板之间的边界</p>
<p><img src="/./../../../BlogImg/image-20250327002955264.png" alt="image-20250327002955264"></p>
<p>这是一个非常基础的屏幕空间的环境光遮蔽</p>
<p><img src="/./../../../BlogImg/image-20250327093254520.png" alt="image-20250327093254520"></p>
<p>更加elegant的解决方法是使用被渲染像素周围几个像素的深度值以更加准确地了解像素周围物体的形状</p>
<h2 id="场景交叉2：制作波浪泡沫和边缘GLA"><a href="#场景交叉2：制作波浪泡沫和边缘GLA" class="headerlink" title="场景交叉2：制作波浪泡沫和边缘GLA"></a>场景交叉2：制作波浪泡沫和边缘GLA</h2><h3 id="注意blender"><a href="#注意blender" class="headerlink" title="注意blender"></a>注意blender</h3><p>注意blender当中使用的坐标系与unity不同，unity是左手，blender是右手，在导出高精度平面的时候要应用变换</p>
<p><img src="/./../../../BlogImg/image-20250327100122876.png" alt="image-20250327100122876"></p>
<p>复制一份之前的wave shadergraph</p>
<p>引入之前的子图</p>
<p><img src="/./../../../BlogImg/image-20250327100417430.png" alt="image-20250327100417430"></p>
<p>我们需要在深度差异较小的地方应用浮沫</p>
<p>这将不同于交叉遮挡着色器</p>
<p>创建一个滑动条属性控制浮沫，数值越大浮沫的长度越大</p>
<p><img src="/./../../../BlogImg/image-20250327100632399.png" alt="image-20250327100632399"></p>
<p><img src="/./../../../BlogImg/image-20250327100757922.png" alt="image-20250327100757922"></p>
<p>当泡沫距离变小的时候divide节点的输出会变大</p>
<p>我们可以使用一个step节点，如果in小于edge则输出0，否则输出1</p>
<p><img src="/./../../../BlogImg/image-20250327100954185.png" alt="image-20250327100954185"></p>
<p>只有当<strong>深度差</strong>小于浮沫距离的时候，也就是相除结果小于1的时候，这个节点输出1，这个step才会被启用</p>
<p><img src="/./../../../BlogImg/image-20250327101426688.png" alt="image-20250327101426688"></p>
<p><img src="/./../../../BlogImg/image-20250327101454327.png" alt="image-20250327101454327"></p>
<p><img src="/./../../../BlogImg/image-20250327102554784.png" alt="image-20250327102554784"></p>
<p>回到shader graph当中，添加一个名为simple noise的节点</p>
<p>之后再添加一个float的foam scale，velocity属性。</p>
<p><img src="/./../../../BlogImg/image-20250327102619138.png" alt="image-20250327102619138"></p>
<p><img src="/./../../../BlogImg/image-20250327104014837.png" alt="image-20250327104014837"></p>
<p><img src="/./../../../BlogImg/image-20250327104144326.png" alt="image-20250327104144326"></p>
<p><img src="/./../../../BlogImg/image-20250327104241890.png" alt="image-20250327104241890"></p>
<p><img src="/./../../../BlogImg/image-20250327105034612.png" alt="image-20250327105034612"></p>
<p><img src="/./../../../BlogImg/image-20250327105024347.png" alt="image-20250327105024347"></p>
<p><strong>解决直线边缘</strong></p>
<p>回到子图当中我们添加offset属性在屏幕空间上进行偏移模拟折射</p>
<p><img src="/./../../../BlogImg/image-20250327105400593.png" alt="image-20250327105400593"></p>
<p><img src="/./../../../BlogImg/image-20250327105544017.png" alt="image-20250327105544017"></p>
<p>保存子图</p>
<p>我们可以发现其它使用了这个子图的shadergraph出现了这个输入</p>
<p><img src="/./../../../BlogImg/image-20250327105711060.png" alt="image-20250327105711060"></p>
<p>添加属性</p>
<p><img src="/./../../../BlogImg/image-20250327105747174.png" alt="image-20250327105747174"></p>
<p><img src="/./../../../BlogImg/image-20250327105757975.png" alt="image-20250327105757975"></p>
<p>使用0到0.1的原因是他代表的是屏幕的比例</p>
<p><img src="/./../../../BlogImg/image-20250327105905868.png" alt="image-20250327105905868"></p>
<p><img src="/./../../../BlogImg/image-20250327105917962.png" alt="image-20250327105917962"></p>
<p>调整offset之后</p>
<p><img src="/./../../../BlogImg/image-20250327105938221.png" alt="image-20250327105938221"></p>
<p>但是仍然有bug</p>
<p><img src="/./../../../BlogImg/image-20250327110032192.png" alt="image-20250327110032192"></p>
<p>修正</p>
<p><img src="/./../../../BlogImg/image-20250327112623587.png" alt="image-20250327112623587"></p>
<p><img src="/./../../../BlogImg/image-20250327110202457.png" alt="image-20250327110202457"></p>
<p>因为shader会把你屏幕上显示的所有物体片元表面与物体遮挡的水面相减并且得到结果，由于我们是小于某个值（这个值在0到1之间）就会绘制浮沫，这个时候就会发生一些问题，所以我们要将其取反，并且根据这个距离重新进行计算。</p>
<p><img src="/./../../../BlogImg/image-20250327110226456.png" alt="image-20250327110226456"></p>
<p>之后</p>
<p><img src="/./../../../BlogImg/image-20250327110240373.png" alt="image-20250327110240373"></p>
<h2 id="边缘发光"><a href="#边缘发光" class="headerlink" title="边缘发光"></a>边缘发光</h2><p>效果</p>
<p><img src="/./../../../BlogImg/image-20250327124632215.png" alt="image-20250327124632215"></p>
<p>这种效果在我们创建类似能量盾的物品的时候非常有用</p>
<p>思路，我们将任何轴上接近于0或者1的uv值都将被注册为物体的发光部分</p>
<p><img src="/./../../../BlogImg/image-20250327125437155.png" alt="image-20250327125437155"></p>
<p><img src="/./../../../BlogImg/image-20250327130312669.png" alt="image-20250327130312669"></p>
<p>之后这样做，把rg单独分离出来，并且相加（得到一个新的vector2）</p>
<p><img src="/./../../../BlogImg/image-20250327130543729.png" alt="image-20250327130543729"></p>
<p>之后获取另一边</p>
<p><img src="/./../../../BlogImg/image-20250327130744888.png" alt="image-20250327130744888"></p>
<p><img src="/./../../../BlogImg/image-20250327130804496.png" alt="image-20250327130804496"></p>
<p><img src="/./../../../BlogImg/image-20250327130823594.png" alt="image-20250327130823594"></p>
<p>事实上，这四个角落会凸显出来，因为发生了两个通道数值的相加</p>
<p><img src="/./../../../BlogImg/image-20250327131028100.png" alt="image-20250327131028100"></p>
<p>注意要保证shader的模式设置的是透明</p>
<p><img src="/./../../../BlogImg/image-20250327131055643.png" alt="image-20250327131055643"></p>
<p>现在的效果</p>
<p><img src="/./../../../BlogImg/image-20250327131139198.png" alt="image-20250327131139198"></p>
<p><img src="/./../../../BlogImg/image-20250327132903009.png" alt="image-20250327132903009"></p>
<p><img src="/./../../../BlogImg/image-20250327132909635.png" alt="image-20250327132909635"></p>
<p>现在的效果</p>
<p><img src="/./../../../BlogImg/image-20250327133139576.png" alt="image-20250327133139576"></p>
<p><img src="/./../../../BlogImg/image-20250327133208847.png" alt="image-20250327133208847"></p>
<p>这种方法的缺点所有的uv接缝都会发光，只能用于一些简单uv的物品</p>
<h2 id="Custom-Functions"><a href="#Custom-Functions" class="headerlink" title="Custom Functions"></a>Custom Functions</h2><p>之前我们使用MainLight来模拟了NPR的照射，但是有时候我们会需要多个灯光照射的结果</p>
<p><img src="/./../../../BlogImg/image-20250327133629064.png" alt="image-20250327133629064"></p>
<p>我们可以在shader graph里面使用自定义函数节点</p>
<p><img src="/./../../../BlogImg/image-20250327134736588.png" alt="image-20250327134736588"></p>
<p>我们需要在asset menu当中创建一个hlsl文件</p>
<p><img src="/./../../../BlogImg/image-20250327134828496.png" alt="image-20250327134828496"></p>
<p><img src="/./../../../BlogImg/image-20250327134918259.png" alt="image-20250327134918259"></p>
<p>其中ADDITIONAL_LIGHT_INCLUDED预处理指令可以防止Unity多次将你的函数包含在生成的代码当中</p>
<p>在里面我们可以自定义任何我们想要的函数，而自定义函数节点可以通过名称调用其中的任何一个函数</p>
<p><img src="/./../../../BlogImg/image-20250327135032534.png" alt="image-20250327135032534"></p>
<p>每一个函数都需要以特殊的方式进行编写</p>
<p><img src="/./../../../BlogImg/image-20250327135426550.png" alt="image-20250327135426550"></p>
<p>我们可以在nodesetting当precision来设置它</p>
<p><img src="/./../../../BlogImg/image-20250327135516875.png" alt="image-20250327135516875"></p>
<p><img src="/./../../../BlogImg/image-20250327135633101.png" alt="image-20250327135633101"></p>
<p>attenuation为1代表这个光源离物体很近被光源完全照亮</p>
<p>而0代表这个光源离物体很远不会被光源照亮</p>
<p><img src="/./../../../BlogImg/image-20250327135919912.png" alt="image-20250327135919912"></p>
<p><img src="/./../../../BlogImg/image-20250327140004286.png" alt="image-20250327140004286"></p>
<p><img src="/./../../../BlogImg/image-20250327140103780.png" alt="image-20250327140103780"></p>
<p>之后我们设定好这个函数</p>
<p><img src="/./../../../BlogImg/image-20250327140151276.png" alt="image-20250327140151276"></p>
<p><img src="/./../../../BlogImg/image-20250327140238279.png" alt="image-20250327140238279"></p>
<p><img src="/./../../../BlogImg/image-20250327140339153.png" alt="image-20250327140339153"></p>
<p><img src="/./../../../BlogImg/image-20250327140413588.png" alt="image-20250327140413588"></p>
<p>然后我们可以将其连接到diffuse上去</p>
<p><img src="/./../../../BlogImg/image-20250327142130998.png" alt="image-20250327142130998"></p>
<p><img src="/./../../../BlogImg/image-20250327142204735.png" alt="image-20250327142204735"></p>
<p>之后我们可以获得和之前一样的漫反射非真实感光照</p>
<p><img src="/./../../../BlogImg/image-20250327142236939.png" alt="image-20250327142236939"></p>
<p>我们将衰减和颜色混入光照当中</p>
<p><img src="/./../../../BlogImg/image-20250327142424643.png" alt="image-20250327142424643"></p>
<p><img src="/./../../../BlogImg/image-20250327142625291.png" alt="image-20250327142625291"></p>
<p><img src="/./../../../BlogImg/image-20250327142652064.png" alt="image-20250327142652064"></p>
<p><strong>进行点光源的限制</strong></p>
<p><img src="/./../../../BlogImg/image-20250327140801311.png" alt="image-20250327140801311"></p>
<p><img src="/./../../../BlogImg/image-20250327141004600.png" alt="image-20250327141004600"></p>
<h3 id="ShaderGraph的限制"><a href="#ShaderGraph的限制" class="headerlink" title="ShaderGraph的限制"></a>ShaderGraph的限制</h3><p>在着色器代码当中，我们可以进行循环<br><img src="/./../../../BlogImg/image-20250327141129391.png" alt="image-20250327141129391"></p>
<p>但是在shadergraph当中，则不能进行循环</p>
<p><img src="/./../../../BlogImg/image-20250327141215458.png" alt="image-20250327141215458"></p>
<p>我们为点光添加照明</p>
<p><img src="/./../../../BlogImg/image-20250327141451630.png" alt="image-20250327141451630"></p>
<p><img src="/./../../../BlogImg/image-20250327141332920.png" alt="image-20250327141332920"></p>
<p><img src="/./../../../BlogImg/image-20250327141428327.png" alt="image-20250327141428327"></p>
<p>将这些部分合并成子图</p>
<p><img src="/./../../../BlogImg/image-20250327141602280.png" alt="image-20250327141602280"></p>
<p>进入子图</p>
<p><img src="/./../../../BlogImg/image-20250327141643513.png" alt="image-20250327141643513"></p>
<p><img src="/./../../../BlogImg/image-20250327141738128.png" alt="image-20250327141738128"></p>
<p><img src="/./../../../BlogImg/image-20250327141823958.png" alt="image-20250327141823958"></p>
<p><img src="/./../../../BlogImg/image-20250327142823119.png" alt="image-20250327142823119"></p>
<p>我们复制出总共四个点光源</p>
<p><img src="/./../../../BlogImg/image-20250327142856119.png" alt="image-20250327142856119"></p>
<p>之后将这些光照叠加起来</p>
<p><img src="/./../../../BlogImg/image-20250327142941425.png" alt="image-20250327142941425"></p>
<p>效果</p>
<p><img src="/./../../../BlogImg/image-20250327142955721.png" alt="image-20250327142955721"></p>
<p>如果这时候我们加入第五个光源，由于shadergraph实际上只处理了4个点光源，移动这个光源可能会出现这个光源替换其他光源的bug</p>
<p><img src="/./../../../BlogImg/image-20250327143203245.png" alt="image-20250327143203245"></p>
<p><img src="/./../../../BlogImg/image-20250327143212869.png" alt="image-20250327143212869"></p>
<p>如果灯光少于4个，事实上这个shadergraph仍然会计算4个光源（shader会创造一个黑光灯来计算颜色）这会造成性能上的浪费</p>
<p>制作另一个计算点光源的函数</p>
<p><img src="/./../../../BlogImg/image-20250327143459035.png" alt="image-20250327143459035"></p>
<p>与之前的代码进行比较</p>
<p><img src="/./../../../BlogImg/image-20250327140801311.png" alt="image-20250327140801311"></p>
<p>这个代码致力于计算场景当中的所有点光源</p>
<p><img src="/./../../../BlogImg/image-20250327143815886.png" alt="image-20250327143815886"></p>
<p><img src="/./../../../BlogImg/image-20250327143800643.png" alt="image-20250327143800643"></p>
<p><img src="/./../../../BlogImg/image-20250327143904044.png" alt="image-20250327143904044"></p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/27/Unity%20%E4%BB%8EBuilt%20in%E5%8D%87%E7%BA%A7%E5%88%B0Universal%20Render%20PipeLine/"><img class="prev-cover" src="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2025/03/26/%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8/"><img class="next-cover" src="https://s3.bmp.ovh/imgs/2023/01/12/1e052378ba7e2bfd.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/OIP.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">某不知名的作者</div><div class="author-info__description">衬衫的价格是九磅十五便士</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tonzinonin" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#UnityShaderGraph"><span class="toc-number">1.</span> <span class="toc-text">UnityShaderGraph</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">1.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%B9%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">纹理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%8F%E6%98%8E"><span class="toc-number">1.3.</span> <span class="toc-text">透明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.4.</span> <span class="toc-text">深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">顶点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%81%AF"><span class="toc-number">1.6.</span> <span class="toc-text">灯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E7%81%AF"><span class="toc-number">1.7.</span> <span class="toc-text">更多灯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NPR"><span class="toc-number">1.8.</span> <span class="toc-text">NPR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%A4%E5%8F%89%E7%9A%84%E7%8E%AF%E5%A2%83%E5%85%89%E9%81%AE%E8%94%BD"><span class="toc-number">1.9.</span> <span class="toc-text">场景交叉的环境光遮蔽</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shader%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4"><span class="toc-number">1.9.1.</span> <span class="toc-text">shader使用技巧复制粘贴</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%A4%E5%8F%892%EF%BC%9A%E5%88%B6%E4%BD%9C%E6%B3%A2%E6%B5%AA%E6%B3%A1%E6%B2%AB%E5%92%8C%E8%BE%B9%E7%BC%98GLA"><span class="toc-number">1.10.</span> <span class="toc-text">场景交叉2：制作波浪泡沫和边缘GLA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8Fblender"><span class="toc-number">1.10.1.</span> <span class="toc-text">注意blender</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E5%8F%91%E5%85%89"><span class="toc-number">1.11.</span> <span class="toc-text">边缘发光</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Custom-Functions"><span class="toc-number">1.12.</span> <span class="toc-text">Custom Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ShaderGraph%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.12.1.</span> <span class="toc-text">ShaderGraph的限制</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/29/Substance%20Painter%20Blender%E5%B7%A5%E4%BD%9C%E6%B5%81/" title="无题"><img src="https://s3.bmp.ovh/imgs/2023/01/12/e92609f7d9e775f5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/03/29/Substance%20Painter%20Blender%E5%B7%A5%E4%BD%9C%E6%B5%81/" title="无题">无题</a><time datetime="2025-03-29T12:39:26.888Z" title="发表于 2025-03-29 20:39:26">2025-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/27/Unity%20%E4%BB%8EBuilt%20in%E5%8D%87%E7%BA%A7%E5%88%B0Universal%20Render%20PipeLine/" title="无题"><img src="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/03/27/Unity%20%E4%BB%8EBuilt%20in%E5%8D%87%E7%BA%A7%E5%88%B0Universal%20Render%20PipeLine/" title="无题">无题</a><time datetime="2025-03-27T09:33:04.691Z" title="发表于 2025-03-27 17:33:04">2025-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/26/UnityShaderGraph/" title="无题"><img src="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/03/26/UnityShaderGraph/" title="无题">无题</a><time datetime="2025-03-26T08:33:02.619Z" title="发表于 2025-03-26 16:33:02">2025-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/26/%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8/" title="无题"><img src="https://s3.bmp.ovh/imgs/2023/01/12/1e052378ba7e2bfd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/03/26/%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8/" title="无题">无题</a><time datetime="2025-03-26T04:48:22.514Z" title="发表于 2025-03-26 12:48:22">2025-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/26/Gpu%E9%98%B3%E6%98%A5%E7%99%BD%E9%9B%AA%E4%B8%8E%E4%B8%8B%E9%87%8C%E5%B7%B4%E4%BA%BA%E7%AC%94%E8%AE%B0/" title="无题"><img src="https://s3.bmp.ovh/imgs/2023/01/12/4bcf264a84775fc0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/03/26/Gpu%E9%98%B3%E6%98%A5%E7%99%BD%E9%9B%AA%E4%B8%8E%E4%B8%8B%E9%87%8C%E5%B7%B4%E4%BA%BA%E7%AC%94%E8%AE%B0/" title="无题">无题</a><time datetime="2025-03-26T02:43:50.830Z" title="发表于 2025-03-26 10:43:50">2025-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>