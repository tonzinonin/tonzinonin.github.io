<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Unity Shader 入门精要扩展 | final fantasy</title><meta name="author" content="某不知名的作者"><meta name="copyright" content="某不知名的作者"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Unity Shader入门精要扩展 表面着色器我的理解是对顶点着色器和片元着色器的一层封装 表面着色器的一个例子Shader &quot;Custom&#x2F;Chapter17_1_BumpDiffuseShader&quot; &amp;#123;     Properties &amp;#123; 		_Color (&quot;Main Color&quot;, Color) &#x3D; (1,1,1,1) 		_MainTex (&quot;Base (RGB)&quot;,">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity Shader 入门精要扩展">
<meta property="og:url" content="https://tonzinonin.github.io/2025/03/17/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E6%89%A9%E5%B1%95/index.html">
<meta property="og:site_name" content="final fantasy">
<meta property="og:description" content="Unity Shader入门精要扩展 表面着色器我的理解是对顶点着色器和片元着色器的一层封装 表面着色器的一个例子Shader &quot;Custom&#x2F;Chapter17_1_BumpDiffuseShader&quot; &amp;#123;     Properties &amp;#123; 		_Color (&quot;Main Color&quot;, Color) &#x3D; (1,1,1,1) 		_MainTex (&quot;Base (RGB)&quot;,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg">
<meta property="article:published_time" content="2025-03-17T13:25:13.000Z">
<meta property="article:modified_time" content="2025-03-30T04:33:14.379Z">
<meta property="article:author" content="某不知名的作者">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg"><link rel="shortcut icon" href="/img/icon.png"><link rel="canonical" href="https://tonzinonin.github.io/2025/03/17/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E6%89%A9%E5%B1%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity Shader 入门精要扩展',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-30 12:33:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/OIP.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">final fantasy</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity Shader 入门精要扩展</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-17T13:25:13.000Z" title="发表于 2025-03-17 21:25:13">2025-03-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-30T04:33:14.379Z" title="更新于 2025-03-30 12:33:14">2025-03-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity Shader 入门精要扩展"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Unity Shader入门精要扩展</p>
<h1 id="表面着色器"><a href="#表面着色器" class="headerlink" title="表面着色器"></a>表面着色器</h1><p>我的理解是对顶点着色器和片元着色器的一层封装</p>
<h2 id="表面着色器的一个例子"><a href="#表面着色器的一个例子" class="headerlink" title="表面着色器的一个例子"></a>表面着色器的一个例子</h2><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">Shader <span class="token string">"Custom/Chapter17_1_BumpDiffuseShader"</span>
<span class="token punctuation">&#123;</span>
    Properties <span class="token punctuation">&#123;</span>
		<span class="token function">_Color</span> <span class="token punctuation">(</span><span class="token string">"Main Color"</span><span class="token punctuation">,</span> Color<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token function">_MainTex</span> <span class="token punctuation">(</span><span class="token string">"Base (RGB)"</span><span class="token punctuation">,</span> <span class="token number">2</span>D<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"white"</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
		<span class="token function">_BumpMap</span> <span class="token punctuation">(</span><span class="token string">"Normalmap"</span><span class="token punctuation">,</span> <span class="token number">2</span>D<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"bump"</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	SubShader <span class="token punctuation">&#123;</span>
		Tags <span class="token punctuation">&#123;</span> <span class="token string">"RenderType"</span><span class="token operator">=</span><span class="token string">"Opaque"</span> <span class="token punctuation">&#125;</span>
		LOD <span class="token number">300</span>
		
		CGPROGRAM
		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">surface surf Lambert</span></span>
		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">target <span class="token number">3.0</span></span></span>

		<span class="token keyword">sampler2D</span> _MainTex<span class="token punctuation">;</span>
		<span class="token keyword">sampler2D</span> _BumpMap<span class="token punctuation">;</span>
		fixed4 _Color<span class="token punctuation">;</span>

		<span class="token keyword">struct</span> <span class="token class-name">Input</span> <span class="token punctuation">&#123;</span>
			float2 uv_MainTex<span class="token punctuation">;</span>
			float2 uv_BumpMap<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

		<span class="token keyword">void</span> <span class="token function">surf</span> <span class="token punctuation">(</span>Input IN<span class="token punctuation">,</span> <span class="token keyword">inout</span> SurfaceOutput o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			fixed4 tex <span class="token operator">=</span> <span class="token function">tex2D</span><span class="token punctuation">(</span>_MainTex<span class="token punctuation">,</span> IN<span class="token punctuation">.</span>uv_MainTex<span class="token punctuation">)</span><span class="token punctuation">;</span>
			o<span class="token punctuation">.</span>Albedo <span class="token operator">=</span> tex<span class="token punctuation">.</span>rgb <span class="token operator">*</span> _Color<span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>
			o<span class="token punctuation">.</span>Alpha <span class="token operator">=</span> tex<span class="token punctuation">.</span>a <span class="token operator">*</span> _Color<span class="token punctuation">.</span>a<span class="token punctuation">;</span>
			o<span class="token punctuation">.</span>Normal <span class="token operator">=</span> <span class="token function">UnpackNormal</span><span class="token punctuation">(</span><span class="token function">tex2D</span><span class="token punctuation">(</span>_BumpMap<span class="token punctuation">,</span> IN<span class="token punctuation">.</span>uv_BumpMap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		
		ENDCG
	<span class="token punctuation">&#125;</span> 
	
	FallBack <span class="token string">"Legacy Shaders/Diffuse"</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/./../../../BlogImg/image-20250320211114399.png"></p>
<p><strong>预处理命令</strong></p>
<p><img src="/./../../../BlogImg/image-20250320211243959.png" alt="image-20250320211243959"></p>
<p><strong>表面函数surf</strong><br><img src="/./../../../BlogImg/image-20250320211408212.png" alt="image-20250320211408212"></p>
<p>里面的参数基于物理渲染而新加的两种结构体</p>
<p>表面函数当中会使用输入结构体Input IN来设置表面的各种属性并且把这些属性存储在输出结构体SurfaceOutput、SurfaceOutputStandard、SurfaceOutputStandardSpecular当中，之后再传递给光照函数计算光照结果。</p>
<p><strong>光照函数</strong></p>
<p>内置的基于物理的光照函数模型Standard和StandardSpecular，以及简单的非基于物理的光照模型Lambert和BlinnPhong。</p>
<p>可以定义自己的光照函数，下面的是前向渲染的光照函数</p>
<p><img src="/./../../../BlogImg/image-20250320211750654.png" alt="image-20250320211750654"></p>
<p><strong>其他可选参数</strong></p>
<p>​	自定义的修改函数：顶点修改函数vertex:VertexFunction、最后的颜色修改函数finalcolor:ColorFunction。前者允许我们自定义一些顶点属性，例如把顶点颜色传递给表面数，或者是修改顶点位置，比如实现某些顶点动画等等。最后的颜色修改函数可以在颜色绘制到屏幕前年最后一次修改颜色值、比如自定义雾效等等。</p>
<p>​	阴影：<br>addshadow为表面着色器生成一个阴影投射的Pass，通常情况下Unity可以直接在FallBack当中找到通用的光照模式为ShadowCaster的Pass，从而将物体正确地渲染到深度和阴影纹理当中，但是对于一些进行了顶点动画、透明度测试的物体，我们就需要对阴影投射进行特殊处理，来为他们产生正确的阴影。<br>fullforwardshadows可以在前向渲染路径中支持所有光源类型的阴影，默认情况下unity只支持平行光的阴影效果。<br>noshader可以禁用阴影</p>
<p>​	透明度测试和透明度混合<br>通过alpha、alphatest指令实现混合和测试。<br>alphatest:VariableName指令会使用变量来剔除不满足条件的片元<br>可以使用上面的addshadow来生成正确的阴影投射的Pass</p>
<p>​	光照<br>noambient：告诉unity不要使用然后环境光和光照探针（light probe）<br>novertexlights：告诉unity不要用任何顶点光照<br>noforwardadd去掉前向渲染当中所有额外的Pass</p>
<p>​	控制代码的生成（控制由表面着色器自动生成的代码）<br>默认情况unity会为一个表面着色器生成相应的前向渲染路径，延迟渲染路径使用的Pass，这会导致生成的Shader文件较大，可以使用exclude_path:defferred、exclude_path:forward、exclude_path:prepass来告诉unity不要为某些渲染路径生成代码</p>
<h2 id="两个结构体"><a href="#两个结构体" class="headerlink" title="两个结构体"></a>两个结构体</h2><p><strong>Input</strong>包含许多表面属性的数据来源（如果自定义了顶点修改函数，他可以是顶点修改函数的输出结构体）</p>
<p>Input内置许多变量名</p>
<p><img src="/./../../../BlogImg/image-20250320213232837.png" alt="image-20250320213232837"></p>
<p>除此之外：uv_MainTex、uv_BumpMap主纹理和法线纹理的变量，这些采样坐标必须用uv为前缀，后接纹理名称</p>
<p>Unity在背后为我们准备好这些数据，我们直接在表面着色器当中使用即可</p>
<p><strong>SurfaceOutput</strong></p>
<p>有了Input结构体来提供所需要的数据之后，我们可以据此计算各种表面属性。因此另一个结构体就是用于存储这些表面属性的结构体，即SurfaceOutput、SurfaceOutputStandard、SurfaceOutputStandardSpecular，它会作为表面函数的输出，随后会作为光照函数的输入来进行各种光照计算。相比与Input结构体的自由性，这个结构体里面的变量是提前就声明好的，不可以增加也不可以减少（如果没有对某些变量赋值，就会使用默认值）。SurfaceOutput的声明可以在Lighting.cginc当中找到</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">struct</span> <span class="token class-name">SurfaceOutput</span>
<span class="token punctuation">&#123;</span>
	fixed3 Albedo<span class="token punctuation">;</span>
	fixed3 Normal<span class="token punctuation">;</span>
	fixed3 Emission<span class="token punctuation">;</span>
	<span class="token keyword">half</span> Specular<span class="token punctuation">;</span>
	<span class="token keyword">fixed</span> Gloss<span class="token punctuation">;</span>
	<span class="token keyword">fixed</span> Alpha<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而SurfaceOutputStandard和SurfaceOutputStandardSpecular的声明可以在UnityPBSLighting.cginc当中找到</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">struct</span> <span class="token class-name">SurfaceOutputStandard</span>
<span class="token punctuation">&#123;</span>
	fixed3 Albedo<span class="token punctuation">;</span>
	fixed3 Normal<span class="token punctuation">;</span>
	half3 Emission<span class="token punctuation">;</span>
	<span class="token keyword">half</span> Metallic<span class="token punctuation">;</span>
	<span class="token keyword">half</span> Smoothness<span class="token punctuation">;</span>
	<span class="token keyword">fixed</span> Alpha<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
   
<span class="token keyword">struct</span> <span class="token class-name">SurfaceOutputStandardSpecular</span>
<span class="token punctuation">&#123;</span>
    fixed3 Albedo<span class="token punctuation">;</span>
    fixed3 Specular<span class="token punctuation">;</span>
    fixed3 Normal<span class="token punctuation">;</span>
    half3 Smoothness<span class="token punctuation">;</span>
    <span class="token keyword">half</span> Occulusion<span class="token punctuation">;</span>
    <span class="token keyword">fixed</span> Alpha<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在一个表面着色器当中，需要选择上述三者当中的其一，这取决于我们选择使用的光照模型。</p>
<p>Unity内置两种光照模型：<br>1，简单的Lambert BlinnPhong<br>2，基于物理的Standard StandardSpecular</p>
<p>使用了简单的非基于物理的，使用SurfaceOutput</p>
<p>使用了基于物理的光照模型Standard和StandardSpecular</p>
<p><img src="/./../../../BlogImg/image-20250320222634204.png" alt="image-20250320222634204"></p>
<h2 id="Unity做了什么"><a href="#Unity做了什么" class="headerlink" title="Unity做了什么"></a>Unity做了什么</h2><p><strong>Unity对Pass的自动生成大概如下</strong></p>
<p><img src="/./../../../BlogImg/image-20250320224135423.png" alt="image-20250320224135423"></p>
<p><img src="/./../../../BlogImg/image-20250320224153811.png" alt="image-20250320224153811"></p>
<p>Unity会根据表面着色器生成一个包含了许多Pass的顶点片元着色器</p>
<p>以unity生成的LightMode为Forward的Pass为例：</p>
<p>1 直接将表面着色器中CGPROGRAM ENDCG之间的代码复制过来，这些代码包括了我们对Input结构体、表面函数、光照函数（如果自定了的话）等变量和函数的定义。这些函数和变量会在之后被当成正常的结构体和函数进行调用</p>
<p>2 Unity分析代码，生成顶点着色器的输出v2f_surf结构体，如果我们在表面着色器Input中定义了某些变量，但是后面没有使用，unity会帮助我们把变量优化掉，不在v2f_surf当中生成。v2f_surf还包含了一些其他变量比如阴影纹理坐标、光照纹理坐标、逐顶点光照</p>
<p>3 生成顶点着色器<br>    如果自定义了顶点修改函数，则会先调用顶点修改函数</p>
<p>​	计算v2f_surf中其他生成的变量值。这主要包括了顶点位置、纹理坐标、法线方向、逐顶点光照、光照纹理的采样坐标等等，可以通过编译指令控制某些变量是否需要计算</p>
<p>​	将v2f surf传递给片元着色器</p>
<p>4 生成片元着色器</p>
<p>​	使用v2f_surf中对应变量填充Input结构体，例如纹理坐标、视角方向等等</p>
<p>​	调用我们自定义的表面函数填充surfaceOutput结构体</p>
<p>​	调用函数得到初始的颜色值</p>
<p>​	进行其他的颜色叠加，例如没有使用光照烘焙，还会添加顶点光照的影响</p>
<p>​	最后如果自定义了最后的颜色修改函数，Unity就会调用它进行最后的颜色修改</p>
<h2 id="表面着色器实例分析-实现对模型的膨胀"><a href="#表面着色器实例分析-实现对模型的膨胀" class="headerlink" title="表面着色器实例分析(实现对模型的膨胀)"></a>表面着色器实例分析(实现对模型的膨胀)</h2><h2 id="表面着色器的缺点"><a href="#表面着色器的缺点" class="headerlink" title="表面着色器的缺点"></a>表面着色器的缺点</h2><p>表面着色器只是Unity在顶点片元着色器上面提供的一种封装</p>
<p>会对性能造成一定的影响，想进行优化，表面着色器难以满足我们的需求</p>
<p>表面着色器无法完成一些自定义的渲染效果，比如透明玻璃的效果</p>
<h1 id="基于物理的渲染PBS"><a href="#基于物理的渲染PBS" class="headerlink" title="基于物理的渲染PBS"></a>基于物理的渲染PBS</h1><p>这只是对于PBS的一个简短介绍</p>
<p>PBS的理论和数学</p>
<p>一些理论可以在Games101里面找到</p>
<h2 id="光是什么："><a href="#光是什么：" class="headerlink" title="光是什么："></a><strong>光是什么</strong>：</h2><p>​	光是一种电磁波，由光源发出来，与场景当中的对象相交，一些被光线吸收、而另一些则是被散射，最后光线被一个感应器吸收成像。</p>
<p>​	材质与光线相交有两种物理现象：<strong>散射和吸收</strong>（以及发光）</p>
<p>​	影响光的一个重要特性是材质的<strong>折射率</strong>。在均匀的介质当中，光是沿着直线传播的。但是如果光在传播时候介质的折射率发生了变化，光的传播方向就会发生变化。特别是，如果折射率是突变的，就会发生光的散射现象。</p>
<p>​	为了渲染对光照建模我经常只考虑两个介质的边界是无限大并且是光学平滑的。</p>
<p>​	尽管真实物体的表面并不是无限延伸的，也不是绝对光滑的。但是和光的波长相比，它们的大小可以被近似认为是无限大以及光学平滑的。</p>
<p>​	再这样的前提下，光在不同介质的边界会被分割成两个方向：反射方向和折射方向。</p>
<p>​	利用<strong>菲涅耳等式</strong>可以描述多少百分比的光会被反射</p>
<p><img src="/./../../../BlogImg/image-20250320232728663.png" alt="image-20250320232728663"></p>
<p>​	上面的图描述了漫反射和镜面反射的原理</p>
<p>​	有的光会被微表面折射到内部，一部分被介质吸收，一部分又被散射到外部，金属往往具有很高的反射系数。因此所有被折射的光往往会被立即吸收，被金属内部的自由电子转化为其他形式的能量。</p>
<p>​	而非金属材质则会同时表现出吸收和散射两种现象。这些被散射出去的光被称为次表面散光。</p>
<p>​	<img src="/./../../../BlogImg/image-20250321000020945.png" alt="image-20250321000020945"></p>
<p>从渲染的层级大小重新审视光与物体表面的交互行为。</p>
<p>​	由微表面反射的光可以被认为是该点上一些方向变化不大的反射光</p>
<p>​	而折射光线需要考虑更多的信息，那些次表面散射光会从不同于入射点的位置从物体内部再次射出，如下方左图。</p>
<p>​	而这些离入射点的距离值和像素大小之间的关系会产生两种建模结构。</p>
<p>​	如果像素要大于这些散射距离，那么意味着这些次表面散射产生的距离可以忽略，我们的渲染可以在局部进行。</p>
<p>​	如果像素要小于这些散射距离，那我们就不能去忽略它们了</p>
<p>​	实现这种特殊的渲染模型，就是次表面散射渲染技术</p>
<p>​	<img src="/./../../../BlogImg/image-20250321000854364.png" alt="image-20250321000854364"></p>
<h2 id="双向反射分布函数BRDF"><a href="#双向反射分布函数BRDF" class="headerlink" title="双向反射分布函数BRDF"></a>双向反射分布函数BRDF</h2><p>我们可以使用<strong>辐射率Radiance</strong>来量化光</p>
<p>辐射率是单位面积单位方向上光源的辐射通量。通常用L来表示。</p>
<p>在渲染当中我们通常会基于表面的入射光线的入射辐射率Li来计算出射辐射率L0，这个过程也往往被称为是着色的过程。</p>
<p>我们要得到出射辐射率L0，可以BRDF函数来模拟物体表面与光的交互，定量分析。</p>
<p>大多数情况下，BRDF可以使用f(l,v)来进行表示，其中I为入射方向和v为观察方向（双向的含义）。</p>
<p>这种情况下，绕着表面法线旋转入射方向或者观察方向并不会影响BRDF的结果。这种BRDF被称作为各项同性的BRDF。与之对应的则是各向异性的BRDF</p>
<p>那么BRDF代表含义是什么呢？</p>
<p>第一种理解：当给定入射角度之后，BRDF可以给出所有出射方向上的反射和散射光线的相对分布情况。</p>
<p>第二种理解：当给定观察方向（出射方向）的时候，BRDF可以给出所有入射方向到该出射方向的光线分布。</p>
<p>一个更加直观的理解是，当一束光线沿着入射方向I到达表面某点的时候，f(I , v)表示了有多少部分的能量被反射到了观察方向v上，</p>
<p><img src="/./../../../BlogImg/image-20250321002516355.png" alt="image-20250321002516355"></p>
<p>书上对这个公式的解释</p>
<p><img src="/./../../../BlogImg/image-20250321003327254.png" alt="image-20250321003327254"></p>
<p>在游戏渲染当中，我们通常是和一些精确的光源打交道，与现实世界一个点要接收四面八方的光照不同。</p>
<p>我们可以用这个等式来计算它在某个方向上的出射辐射率</p>
<p><img src="/./../../../BlogImg/image-20250321003530647.png" alt="image-20250321003530647"></p>
<p>大大简化了计算。</p>
<p>如果场景中包含了多个精确光源，我们可以把它们分别带入上面的算式进行计算然后相加得到结果。</p>
<p>下面我们来看BRDF是如何得到的。可以看出BRDF决定了着色过程是否是基于物理的。这可以由BRDF是否满足两个特性来进行判断：它是否满足交换律和能量守恒。</p>
<p><img src="/./../../../BlogImg/image-20250321003903319.png" alt="image-20250321003903319"></p>
<p>基于这些理论BRDF可以用来描述两种不同的物理现象：表面反射和次表面反射。</p>
<p>在BRDF中有两个部分描述：描述反射的是高光反射项，描述次表面反射的是漫反射项。</p>
<p><strong>漫反射项</strong></p>
<p>lambert模型是最简单也是应用最广泛的BRDF，而准确的Lambertian BRDF被描述为</p>
<p><img src="/./../../../BlogImg/image-20250321004213720.png" alt="image-20250321004213720"></p>
<p>书上所讲的BRDF中的漫反射项与Lambert的不同之处<br><img src="/./../../../BlogImg/image-20250321004406391.png" alt="image-20250321004406391"></p>
<p>总之，这个式子实际上是一个定值，余弦实际上是定值，包括在所谓的反射等式中，不包括在BRDF中，整除pi是因为brdf在<strong>半球</strong>内的积分值为1，，，</p>
<p>更加复杂的漫反射</p>
<p><img src="/./../../../BlogImg/image-20250321004956308.png" alt="image-20250321004956308"></p>
<p>总之，迪士尼反射考虑了更多，考虑了在掠射角漫反射项的能力变化，以及表面粗糙度对漫反射的影响。</p>
<p><strong>高光反射项</strong></p>
<p>BDRF的高光反射项大多建立在微面元理论的假设上。</p>
<p>现在只考虑被反射的光线，折射光线在漫反射的时候已经讨论过了、</p>
<p>仍然有一些材质无法使用微面理论来进行描述</p>
<p><img src="/./../../../BlogImg/image-20250321005345929.png" alt="image-20250321005345929"></p>
<p><img src="/./../../../BlogImg/image-20250321005352513.png" alt="image-20250321005352513"></p>
<p>总之，只有一部分微面元反射的光线会进入到我们眼睛当中。</p>
<p>这个微元面上的法线也叫作半角度矢量</p>
<p><img src="/./../../../BlogImg/image-20250321005405916.png" alt="image-20250321005405916"></p>
<p><img src="/./../../../BlogImg/image-20250321005410280.png" alt="image-20250321005410280"></p>
<p>总之，某些光源方向被遮挡的微元面上的反射不会全部加入计算，即使现实仍然有其他地方的漫反射会计入，但是不在讨论范围之内</p>
<p><img src="/./../../../BlogImg/image-20250321005423018.png" alt="image-20250321005423018"></p>
<p><img src="/./../../../BlogImg/image-20250321010642469.png" alt="image-20250321010642469"></p>
<p>总之D(h)是微面元的法线分布函数，用于计算多少比例微面元法线满足m&#x3D;h，只有这部分才可以发生I到v的反射</p>
<p>G(I , v , h)是阴影——遮掩函数，它用于计算那些满足m &#x3D; h的微面元中会有多少由于遮挡而不会被人眼看到，它给出了活跃的微面所占的浓度。只有活跃的微面元才会成功地把光线反射到观察方向上。</p>
<p>F(I,h)是活跃微面元的菲涅尔反射系数，表示了反射光线占据入射光线的比例。</p>
<p>分母用于校正微面元的局部空间到整体宏观数量差异的校正因子。</p>
<p><img src="/./../../../BlogImg/image-20250321011259634.png" alt="image-20250321011259634"></p>
<p>还有更多复杂的模型如GGX[3],Beckmann[4]</p>
<h2 id="Unity5实现PBS"><a href="#Unity5实现PBS" class="headerlink" title="Unity5实现PBS"></a><strong>Unity5实现PBS</strong></h2><p>Unity有两种基于物理的工作流程，金属工作流和高光反射工作流</p>
<p>其中金属工作流是默认的工作流程，对应的Shader为Standard Shader。</p>
<p>高光反射工作流则是Standard（Specular Setup）</p>
<p>不同的工作流可以实现相同的效果，只是它们使用的参数不同。</p>
<p><strong>如何实现</strong></p>
<p>源代码在Unity内置的builtin_shaders-5.x&#x2F;DefaultResourceExtra当中得到，这些shader以来builtin_shaders-5.x&#x2F;CGIncludes文件夹中定义的一些头文件。</p>
<p>其中定义了许多和PBS相关的各个函数、结构体、宏等</p>
<p><img src="/./../../../BlogImg/image-20250321100715868.png" alt="image-20250321100715868"></p>
<p>总体来讲Standard.shader和StandardSpecular.shader的代码基本相同</p>
<p>第一个subshader使用的计算更加复杂，主要针对非移动平台。</p>
<p>并且定义了前向渲染、延迟渲染路径使用的Pass，以及用于投射阴影和提取元数据的Pass，第二个SubShader定义了4个Pass，其中两个Pass用于前向渲染路径，一个Pass用于投射投影，另一个Pass用于提取元数据，</p>
<p>第二SubShader定义了4个Pass，其中两个Pass用于前向渲染路径，一个Pass用于投射投影，另一个Pass用于提取元数据，主要面对移动平台</p>
<p>最大的不同：它们在设置BRDF的输入的时候使用了不同的函数来设置各个参数——基于金属工作流的StandardShader使用MetallicSetup函数来设置各个参数，基于高光反射工作流的Standard（Specular Setup）使用SpecularSetup函数来设置</p>
<p>两个Pass的代码大体相同，只是ForwardBase Pass进行了更多的光照计算，例如计算全局光照、自发光等效果。</p>
<h2 id="使用Standard-Shader"><a href="#使用Standard-Shader" class="headerlink" title="使用Standard Shader"></a>使用Standard Shader</h2><p><img src="/./../../../BlogImg/image-20250321103335512.png" alt="image-20250321103335512"></p>
<p><strong>金属材质</strong></p>
<p>几乎没有漫反射，因为所有被吸收的光都会被自由电子立刻转化为其他形式的能量。</p>
<p>有非常强烈的高光反射</p>
<p>高光反射通常是有颜色的，例如金子的反光颜色为黄色。</p>
<p><strong>非金属材质</strong></p>
<p>大多数角度高光反射的强度比较弱，但是在掠射角时高光反射轻度反而会增强，即菲涅耳现象。</p>
<p>高光反射的颜色比较单一</p>
<p>漫反射的颜色多种多样</p>
<p>——————</p>
<p>Unity的工作流就是更加方便的让我们针对以上特性来调整材质效果</p>
<p>下面是两种校准表格</p>
<p><img src="/./../../../BlogImg/image-20250321103824220.png" alt="image-20250321103824220"></p>
<p><img src="/./../../../BlogImg/image-20250321103840643.png" alt="image-20250321103840643"></p>
<p><img src="/./../../../BlogImg/image-20250321104015896.png" alt="image-20250321104015896"></p>
<p><strong>MainMap部分</strong></p>
<p>在金属工作流中，albedo定义了物体的整体颜色</p>
<p>非金属的亮度范围在50<del>243之间，而金属材质的亮度一般在186</del>255之间</p>
<p>我们可以使用一张纹理作为albedo值</p>
<p>也可以用一张纹理采样得到metallic值</p>
<p>smoothness是上一个属性metallic的附属值，定义了从视觉上来看该表面的光滑程度。</p>
<p>如果我们在设置metallic属性的时候使用的是一张纹理，那么这张纹理的A通道就对应了表面的Smoothness值</p>
<p>高光反射工作流使用的面板几乎相同</p>
<p>只是使用了不同含义的albedo属性，并且使用了Specular代替了上述的Metallic属性。</p>
<p>在高光反射工作流当中，材质的albedo属性定义了表面的漫反射强度。</p>
<p>对于非金属物体，albedo的值被认为是视觉上的物理颜色，对于金属材质，albedo的值通常非常接近黑色（因为黑色会吸收次表面反射，金属几乎不存在次表面反射）</p>
<p>Specular属性定义了表面的高光反射强度，非金属通常使用灰度值0~55的深灰色代表Specular值，表面高光反射较弱</p>
<p>金属材质会使用视觉上认为的该金属颜色来作为specular值。</p>
<p>Smoothness定义了光滑程度，specular纹理的alpha值即为smoothness</p>
<p><strong>渲染模式</strong></p>
<p>Opaque：不透明物体</p>
<p>Transparent：玻璃等不透明物体</p>
<p>Cutout：albedo上的alpha值会成为一个掩码纹理，它的子属性alpha cutoff将会是透明度测试时候使用的阈值</p>
<p>Fade：和transparent类似，但是当材质透明度降低的时候所有渲染效果都会从屏幕上淡出，transparent则可以保留高光</p>
<h2 id="一个更加复杂的例子"><a href="#一个更加复杂的例子" class="headerlink" title="一个更加复杂的例子"></a>一个更加复杂的例子</h2><p>使用HDR格式的cubemap作为skybox，可以让场景中物体的反射更加真实。</p>
<p><strong>什么是全局光照</strong></p>
<p><strong>概念：</strong>模拟光线是如何在场景中进行传播的，它不仅会考虑那些直接光照的结果，还会计算光线被不同物体表面反射而产生的间接光照。</p>
<p>在使用基于物理的着色技术的时候，当渲染表面上一点时，我们需要计算该点的半球范围内所有会反射到观察方向的入射光线的光照结果，这些入射光线中就包含了直接光照和间接光照。</p>
<p>通常来说这些间接光照的计算非常耗时间，通常不会用在实时渲染当中</p>
<p>Unity采用来Enlighten方案来让全局光照在各种平台上有不错的性能表现</p>
<p>预计算光照包含了我们常见的光照烘焙，也就是指我们把光源对场景中静态物体的光照效果提前烘焙到一张光照纹理当中。然后把这张光照纹理直接贴在这些物体的表面，来获得光照效果，这些光照纹理不仅存储了直接光照的结果，还包含了那些由物体反射得到的间接光照。</p>
<p>由于静态的光照烘焙无法在光照条件改变的时候更新物体的光照效果，因此unity使用了预计算实时全局光照为我们提供了一个解决途径，来动态地为场景实时更新复杂的光照效果。并且这些效果都是实时的。</p>
<p><strong>如何实现：</strong>一旦物体和光源的位置被固定了，这些物体对光线的反弹路径以及漫反射光照也是固定的，也就是说和摄像机无关的。因此我们可以使用与计算来把这些物体的关系提前计算出来。在实时运行的时候，只要光源的位置不变，即便改变了光源的颜色和强度、物体材质属性，这些信息就一直有效，不需要实时更新。</p>
<p>在预计算阶段Enlight会在所有静态物体组成的场景上进行简化的光线追踪处理。在这个过程Enlight会自动把场景分割成很多的子系统，它并不是为了得到精确的光照效果，而是为了得到场景中物体之间的关系。</p>
<p>我们至少要把场景中的一个物体勾选上static才能使用</p>
<p>另一个例外的高光反射，这是和摄像机的位置相关的，unity的解决方法是使用光照探针。对于动态移动的物体，我们使用光照探针来模拟它的光照环境。</p>
<p>因此在实时运行的时候unity会利用预计算得到的信息来计算光照信息，并且把它们存储在额外的光照纹理当中。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a></div><div class="post_share"><div class="social-share" data-image="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/25/Unity%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/"><img class="prev-cover" src="https://s3.bmp.ovh/imgs/2023/01/12/f8943481ff2f250b.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2025/03/16/%E5%9C%A8UnityShader%E5%BD%93%E4%B8%AD%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E9%97%AE%E9%A2%98/"><img class="next-cover" src="https://s3.bmp.ovh/imgs/2023/01/12/4380663e3f60c5ab.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/03/10/Unity%202D_RPG%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0/" title="Unity Shader 入门精要高级"><img class="cover" src="https://s3.bmp.ovh/imgs/2023/01/12/1e052378ba7e2bfd.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-10</div><div class="title">Unity Shader 入门精要高级</div></div></a></div><div><a href="/2022/10/28/Unity%20%E4%BB%8EBuilt%20in%E5%8D%87%E7%BA%A7%E5%88%B0Universal%20Render%20PipeLine/" title="Unity 从Built in升级到Universal Render PipeLine"><img class="cover" src="https://s3.bmp.ovh/imgs/2023/01/12/4380663e3f60c5ab.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-28</div><div class="title">Unity 从Built in升级到Universal Render PipeLine</div></div></a></div><div><a href="/2022/10/28/Unity%20%E5%B0%84%E5%87%BB%E7%94%9F%E5%AD%98%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0/" title="Unity 设计生存游戏制作笔记"><img class="cover" src="https://s3.bmp.ovh/imgs/2023/01/12/6b712c90bf59be49.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-28</div><div class="title">Unity 设计生存游戏制作笔记</div></div></a></div><div><a href="/2025/03/13/Unity%20Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7/" title="Unity Shader 入门精要中级"><img class="cover" src="https://s3.bmp.ovh/imgs/2023/01/12/1e052378ba7e2bfd.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-13</div><div class="title">Unity Shader 入门精要中级</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/OIP.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">某不知名的作者</div><div class="author-info__description">衬衫的价格是九磅十五便士</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tonzinonin" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E9%9D%A2%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">表面着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E9%9D%A2%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">表面着色器的一个例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.</span> <span class="toc-text">两个结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.</span> <span class="toc-text">Unity做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E9%9D%A2%E7%9D%80%E8%89%B2%E5%99%A8%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%86%A8%E8%83%80"><span class="toc-number">1.4.</span> <span class="toc-text">表面着色器实例分析(实现对模型的膨胀)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E9%9D%A2%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">表面着色器的缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%B8%B2%E6%9F%93PBS"><span class="toc-number">2.</span> <span class="toc-text">基于物理的渲染PBS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">光是什么：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%8F%8D%E5%B0%84%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0BRDF"><span class="toc-number">2.2.</span> <span class="toc-text">双向反射分布函数BRDF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity5%E5%AE%9E%E7%8E%B0PBS"><span class="toc-number">2.3.</span> <span class="toc-text">Unity5实现PBS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Standard-Shader"><span class="toc-number">2.4.</span> <span class="toc-text">使用Standard Shader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%8A%A0%E5%A4%8D%E6%9D%82%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">2.5.</span> <span class="toc-text">一个更加复杂的例子</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/29/Substance%20Painter%20Blender%E5%B7%A5%E4%BD%9C%E6%B5%81/" title="无题"><img src="https://s3.bmp.ovh/imgs/2023/01/12/4bcf264a84775fc0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/03/29/Substance%20Painter%20Blender%E5%B7%A5%E4%BD%9C%E6%B5%81/" title="无题">无题</a><time datetime="2025-03-29T12:39:26.888Z" title="发表于 2025-03-29 20:39:26">2025-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/26/UnityShaderGraph/" title="无题"><img src="https://s3.bmp.ovh/imgs/2023/01/12/1e052378ba7e2bfd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/03/26/UnityShaderGraph/" title="无题">无题</a><time datetime="2025-03-26T08:33:02.619Z" title="发表于 2025-03-26 16:33:02">2025-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/26/%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8/" title="无题"><img src="https://s3.bmp.ovh/imgs/2023/01/12/6b712c90bf59be49.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/03/26/%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E5%85%A5%E9%97%A8/" title="无题">无题</a><time datetime="2025-03-26T04:48:22.514Z" title="发表于 2025-03-26 12:48:22">2025-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/26/Gpu%E9%98%B3%E6%98%A5%E7%99%BD%E9%9B%AA%E4%B8%8E%E4%B8%8B%E9%87%8C%E5%B7%B4%E4%BA%BA%E7%AC%94%E8%AE%B0/" title="无题"><img src="https://s3.bmp.ovh/imgs/2023/01/12/4380663e3f60c5ab.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/03/26/Gpu%E9%98%B3%E6%98%A5%E7%99%BD%E9%9B%AA%E4%B8%8E%E4%B8%8B%E9%87%8C%E5%B7%B4%E4%BA%BA%E7%AC%94%E8%AE%B0/" title="无题">无题</a><time datetime="2025-03-26T02:43:50.830Z" title="发表于 2025-03-26 10:43:50">2025-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/25/Unity%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/" title="无题"><img src="https://s3.bmp.ovh/imgs/2023/01/12/f8943481ff2f250b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/03/25/Unity%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/" title="无题">无题</a><time datetime="2025-03-25T11:28:52.056Z" title="发表于 2025-03-25 19:28:52">2025-03-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>