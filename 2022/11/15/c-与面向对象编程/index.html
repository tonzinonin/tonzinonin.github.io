<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>c++与面向对象编程1 | final fantasy</title><meta name="author" content="某不知名的作者"><meta name="copyright" content="某不知名的作者"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学会使用visual studio 2022 cpp相比于c，除了新增的一大堆stl里的方法外，还有面向对象编程这一重要的特性 为什么不建议使用using namespace std;因为这会造成命名空间的污染 比如你在引用了stl和某一个库nameless，恰好这两个库都包含有vector这个函数，这个时候你如果直接使用using namespace std;和using namespace n">
<meta property="og:type" content="article">
<meta property="og:title" content="c++与面向对象编程1">
<meta property="og:url" content="https://tonzinonin.github.io/2022/11/15/c-%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="final fantasy">
<meta property="og:description" content="学会使用visual studio 2022 cpp相比于c，除了新增的一大堆stl里的方法外，还有面向对象编程这一重要的特性 为什么不建议使用using namespace std;因为这会造成命名空间的污染 比如你在引用了stl和某一个库nameless，恰好这两个库都包含有vector这个函数，这个时候你如果直接使用using namespace std;和using namespace n">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg">
<meta property="article:published_time" content="2022-11-15T05:14:12.000Z">
<meta property="article:modified_time" content="2023-01-12T14:13:41.520Z">
<meta property="article:author" content="某不知名的作者">
<meta property="article:tag" content="Cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg"><link rel="shortcut icon" href="/img/icon.png"><link rel="canonical" href="https://tonzinonin.github.io/2022/11/15/c-%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'c++与面向对象编程1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-12 22:13:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/OIP.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">final fantasy</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">c++与面向对象编程1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-15T05:14:12.000Z" title="发表于 2022-11-15 13:14:12">2022-11-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-12T14:13:41.520Z" title="更新于 2023-01-12 22:13:41">2023-01-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="c++与面向对象编程1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>学会使用visual studio 2022</p>
<p>cpp相比于c，除了新增的一大堆stl里的方法外，还有面向对象编程这一重要的特性</p>
<p>为什么不建议使用using namespace std;<br>因为这会造成命名空间的污染</p>
<p>比如你在引用了stl和某一个库nameless，恰好这两个库都包含有vector这个函数，这个时候你如果直接使用using namespace std;和using namespace nameless;当你在文件中使用vector这个函数的时候，你难以判断这个vector是对应哪个头文件下的function，这对于代码的可读性和健壮性是有很大影响的，尤其是到了需要团队协作的时候，所以这是为什么不建议使用namespace std;</p>
<h1 id="从0重新开始的c-学习之旅"><a href="#从0重新开始的c-学习之旅" class="headerlink" title="从0重新开始的c++学习之旅"></a>从0重新开始的c++学习之旅</h1><h3 id="C-的原理："><a href="#C-的原理：" class="headerlink" title="C++的原理："></a>C++的原理：</h3><p>你有一些源文件，上面有你写的文本，这些文本会通过编译器被转换成二进制文件，这个binary可以说某种库，或者是实际的可执行文件excutable。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这个函数主要是等待一个回车执行下一行代码</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先我们有#include<iostream>语句，这种语句叫做preprocessor语句（预处理指令）<br>任何以#开头的指令都是预处理指令。<br>当编译器收到一个源文件的时候它做的第一件事就是预处理你所有的预处理指令(preprocessor statement)<br>它们发生在真正的编译之前</p>
<p>include所做的事就是找到一个文件，在此处我们找的是一个叫做iostream的文件。该文件里的所有内容都会被复制黏贴到目前这个文件里。你include的文件一般被称为头文件。<br>你可以生成一个只有一个”}”的.h文件，之后可以在其它文件中通过引用该头文件来代替”}”，这也体现了include的实现方式便是复制粘贴。</p>
<p>include里提供流输入输出函数cout，cout可以使我们能够打印东西到控制台上，然后我们就有这个main函数，main函数非常的重要，因为每个c++程序都有类似这个main函数的东西，它又被称作入口点（entry point）<br>当我们要运行我们的程序时，计算机会从该函数的代码里开始执行，程序运行的时候，我们电脑会一行一行按照顺序运行我们写的代码。（control flow statement控制流语句）或者是调用其它的函数。</p>
<p>cout后的&lt;&lt;实际上是被重载的符号，可以把它视为作用为打印的function</p>
<p>源文件变为可执行文件：<br>1.首先是includeiostream这段preprocessor将会在编译之前被评估。<br>2.之后编译，c++代码转化为实际的机器码。</p>
<p>在vs中有几个很重要的设置来决定这一切是如何发生的：<br>在visualstudio，我们可以看到debug和x86这两个选项，如果点开debug，会发现debug和release这两个选项，这两个选项在vs里是新建项目时候的默认设置。在x86我们可以看到x64和x86两个设置。</p>
<p>configuration只是一系列规则用于如何build一个项目。<br>而solution platform,是我们目前编译的目标平台。比如x86就是定位于32位windows，也就是说我们会生成一个用于windows的32位程序。<br>复杂的项目将会面向不同的平台。你可能会有一个安卓平台，然后如果你想build，部署，以及debug安卓程序，你就得把平台改成安卓。<br>至于solutionconfiguration是定义如何为这个平台编译的一系列规则。</p>
<p>属性properities板块：<br>首先要注意configuration和platform两个区域，确保你的configuration和platform有被设置为你确实想要修改的那个选项。<br>SDK，即Software Development Kit的缩写，即软件开发工具包<br>值得注意的是，vs默认将配置类型(configuration type)设置为应用程序(.exe)，如果我们需要写一个库，我们可以在这里修改，都是这就是编译会产出的二进制文件了。<br>C&#x2F;C++是编译器设置。<br>注意Additional Include Directories,可以用这个来引用第三方库。属性里还有很多的其它东西，比如可能需要用到的优化设置，代码生成设置，预处理定义等等</p>
<p>在release的情况下,编译器会自动调整成O2优化，而在debug的情况下则是disabled状态，这就是debug模式默认比release慢的原因。<br>事实上，关闭优化更有助于我们进行debug。</p>
<p>所有cpp文件都会被编译，header file不会。<br>所有的cpp文件都会被编译成一个object文件，.obj为后缀名。当我们有了一个个obj文件，也就是cpp文件被编译之后的结果，我们需要有办法把它们联系起来，组成一个exe文件。这就是链接器的作用了。详情可以参考csapp上的内容。</p>
<p>你可以在linker标签下看到linker的设定，但是基本上linker就是把obj全部拿过来，然后把它们联系起来，组成一个exe。</p>
<p>vs中errorlist报错的直观性不如output窗口<br>vs中ctrl+f7进行compile，当你单独编译一个文件linking(链接)显然不会发生，因为你是单独编译一个文件。<br>项目里每一个文件都会生成一个obj。<br>build：不止编译一个文件而是整个项目，build之后我们可以在solution(x64)&#x2F;debug文件夹里找到exe文件。</p>
<p>出现LINK1168错误：<br>重启电脑，本质上是因为之前的运行窗口没有关闭</p>
<p>出现LINK2019错误：<br>举一个教程中的例子<br>比如<br>error LNK2019: unresolved external symbol “void __cdecl Log(char const *)” (?Log@@YAXPEBD@Z) referenced in function main<br>它基本上在告诉你，你有一个没有被解析的外部标记(external symbol)叫log，unresolved external symblo意思是linker无法解析一个symbol<br>记住，linker的工作就是resolve symbols，联通各个函数，而它无法找到log应该跟谁联系起来，因为我们没有log这个函数的定义，可以通过更正函数名来解决。</p>
<h3 id="cpp-compile的工作原理。"><a href="#cpp-compile的工作原理。" class="headerlink" title="cpp compile的工作原理。"></a>cpp compile的工作原理。</h3><p>cpp文件从text到可执行的bin，基本上有两个主要操作需要发生。一步是编译，一步是链接。<br>首先需要进行预处理，被预处理了之后，我们会进入tokenizing和parsing阶段。<br>基本结果就是创建某种abstract syntax tree(抽象语法树)，也就是我们代码的表达，但是是以抽象语法树的形式。<br>编译器的工作要么是把代码转换为constant data(常数资料)，要么就是instruction(指令)，当编译器创建了这颗抽象语法树之后，就可以产生代码了，这个代码是真正从cpu会执行的机器码。同时，我们也会得到一些其他数据，比如某个地方存储着我们所有的constant variables。</p>
<p>拿之前的例子来说，build项目之后i，项目目录的debug目录下生成了main.obj,log.obj，output的debug目录下生成了一个exe。<br>也就是编译器给每一个cpp，也就是每个translation unit(编译单元)，生成了obj。事实上cpp根本不在乎文件，文件这种东西在cpp里根本不存在。举例说，在java里，你的class类名必须和文件名相同，而你的文件夹结构也得跟package一样。之所以如此是因为java需要某一些文件存在，而c++完全不是这么回事，没有文件这种东西，文件只是用来给编译器提供源码的某一种方法。<br>你需要告诉编译器文件类型和编译器该如何处理它。<br>你建一个cpp文件，编译器就会把它当作cpp文件，这只是默认的既成习惯，你可以通过改变编译器的设定来改变它们，我们同样可以设置编译器对.love进行编译。文件不代表任何东西。</p>
<p>我们有一个方法输出preprocessor的结果，可以在属性里将preprocess to a file修改为yes，这样就可以在文件夹中通过某个.i后缀文件查看编译前预处理后的文件。</p>
<p>“#if与#endif”语句，可以人我们依据特定条件包含或者剔除代码。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">表达式</span></span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"speaker"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果表达式的结果为false，那么预处理后的文件当中便不会出现printf(“speaker”);这一行代码。<br>反之则会出现这一行代码。</p>
<p>之后我们在debug里打开filename.obj文件，会发现出现一堆16进制的代码，事实上这是二进制文件，只不过我们的打开方式以16进制的形式来呈现。<br>我们可以在属性里通过将assembla output设置为assembly-only listing，点ok，按ctrl+f7。之后在output目录下，我们可以看到一个叫filename.asm文件。这基本就是刚才那个obj所包含内容的一个可读版本。我们可以看到里面有一堆的汇编指令。<br>这些是我们运行函数的时候cpu真正会去运行的指令，所谓的o2优化直接体现在这些内容上。</p>
<p>如果我们直接打开release，会发现o2和rtc其实是不兼容的，所以我们需要回到code generation，确保basic runtime checks设置为default，也就是不会运行时检查(runtime checks)其实就是编译器会插入的一些代码来帮助我们debugging。<br>所谓常量折叠(constant folding)，也就是任何常量都可以在编译的时候算出来。</p>
<p>在汇编文件当中，log函数会被装饰成带有随机字符和@符号的样子，这其实时函数签名，它需要独一无二的定义你的函数。但是事实上当我们有多个obj的时候，我们的函数会在多个obj当中被定义，linker会负责将它们联系起来。它会查找这个函数签名来做到这一点。</p>
<h3 id="cpp的linking"><a href="#cpp的linking" class="headerlink" title="cpp的linking"></a>cpp的linking</h3><p>linking是从cpp源码到可执行二进制时的一个过程。编译了文件之后，我们需要一个叫做链接的过程。主要工作时找到每个符号和函数的位置，并且将它们链接在一起。</p>
<p>每个文件被编译成一个独立的obj文件作为translation unit它们之间没有关系，这些文件实际上无法进行沟通。<br>就是只有一个文件得时候你也会需要linking，因为应用程序需要知道入口点再拿里，也就是找到主函数的位置。</p>
<p>complie(ctrl + f7)的时候只有compile，当进行build(F5)的时候才会发生linking。<br>报错前缀为C是编译错误，LNK是链接错误。<br>每一个exe文件必须有一个入口点，不然就会报错。我们可以在属性的Linker&gt;&gt;Advanced中自定义entry point，入口点不一定是main函数。</p>
<p>比如这样的报错：<br>error LNK2019: unresolved external symbol “void __cdecl Log(char const *)” (?Log@@YAXPEBD@Z) referenced in function main<br>说明当主函数main需要调用Log这一个函数的时候，链接器找不到Log这一个函数，于是报错，然而如果文件里没有调用这个Log函数，也就不会产生对Log的链接，于是无事发生。但是如果在真的在a函数里调用了Log，即使你没调用过这个a函数，也会报linker错误。<br>因为虽然我们没有在这个函数中使用a函数，但是计数技术上来讲我们可能在另一个文件中使用它。因此linker确实需要链接它。</p>
<p>如果我们有办法告诉编译器这个a函数我只会在这个文件当中使用它，那么我可以消除这种linking的必要，因为a函数从未被调用过，它永远不需要调用log。<br>事实上如果我们在函数名的前面加上static这一个关键字，这基本上意味着这个a函数只是为了这个翻译单元声明的。因为a函数从来没有在这个文件里调用过，如果build，不会发生任何的linking错误。</p>
<p>在调用其它文件的函数时，必须要做到函数的签名相同，比如函数名，返回值的类型，参数类型。。。不然会报lnk错误。<br>void Log(const char* message);</p>
<p>另一种常见的链接错误是当我们有函数或者变量有相同的名字和签名的时候，也就是两个相同名称的函数具有相同的返回值和相同的参数。连接器不知道哪个链接到哪个。<br>比如当在两个文件中同时include一个头文件，里面有一个不带任何修饰的函数a，这个时候根据include的特性，两个<strong>编译单元</strong>（cpp文件）中会同时声明一个函数a，这时候就会爆LNK错误。<br>但是如果我们在函数a前加上<strong>static</strong> 修饰，就意味着这个log函数链接时链接只应该发生在该文件的内部。也就是说，当这个a函数被include到两个编译单元中的时候，只会对该文件的内部有效。<br>另一种方法是加上<strong>inline</strong>，所谓内联函数，就是直接把函数的身体拿过来进行调用，就不会出现引用函数名的问题。<br>再一种方法是把它的定义移动到另一个翻译单元当中。比如再翻译单元1中定义a函数，再到头文件里留下声明</p>
<h3 id="cpp中的变量与函数"><a href="#cpp中的变量与函数" class="headerlink" title="cpp中的变量与函数"></a>cpp中的变量与函数</h3><p>数据类型的实际大小取决于编译器。<br>直接声明float a &#x3D; 4.5事实上4.5是一个double类型的数据，4.5f加上一个f之后才会变成float。</p>
<p>由于在内存当中，我们没有办法寻址到每一个bit，只能寻址到每一个字节，所以我们不能每bit地访问内存，于是bool事实上是1个字节的大小。</p>
<p>在调用函数的过程中，编译器会产生一个调用指令，为这个函数创建一整个栈框架，使速度变慢，除非是内联函数。</p>
<p>主函数是一个特殊的函数，可以不用写return 0。</p>
<h3 id="cpp当中的头文件"><a href="#cpp当中的头文件" class="headerlink" title="cpp当中的头文件"></a>cpp当中的头文件</h3><p>事实上头文件是cpp比较特殊的一种特性，它本质上是代码的复制粘贴。<br>可以在头文件里定义函数的声明来避免函数签名的冲突。</p>
<p>“#pragma once”<br>由于这个指令带了#号，说明这个指令是一个preprocessor指令。<br>pragma once其实意思是说只会include这个文件一次。这个命令有时候也被称为header guard(头文件保护符)，能够防止我们把单个头文件多次include到一个单一翻译单元里。</p>
<p>比如你有Common.h这个头文件</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Log.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后又有Log.h这个头文件</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Log</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在一个编译单元里你同时包含</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Log.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Common.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这个时候编译器就会报错，因为事实上，Log.h被编译单元引用了两次，如果加上pragma once，则比较容易能够避免这种问题。</p>
<p>”#ifndef“<br>这个指令也是保护头文件用的，</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//Common.h</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_LOG_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_LOG_H</span></span>

<span class="token keyword">void</span> <span class="token function">Log</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果在文件中检测到了_LOG_H这个宏定义，那么程序就会终止运行。这使得这个头文件事实上只会在编译单元里被包含最多一次。</p>
<p>include “”和include &lt;&gt;的区别：<br>“”会在文件的相对位置寻找头文件，&lt;&gt;会在所有include目录里寻找头文件。</p>
<h3 id="vs的debug："><a href="#vs的debug：" class="headerlink" title="vs的debug："></a>vs的debug：</h3><p>什么是断点。<br>断点是程序中调试器会中断的一个点，也就是暂停。我们可以在程序的任何一行代码上设置断点。当执行到达这一行的时候，它就会暂停。<br>debug：<br>确保断点设置在可执行的代码上。<br>确保处于debug模式，因为当处于release模式时，编译器可能会改变你的代码，你的断点可能永远不会被执行，因为你的程序被重新安排了。<br>点击Local windows debug<br>会显示一个黄色的箭头，指示当前指令指针所在的位置，但是这一行代码并没有被执行。<br>continue将继续执行程序。<br>step into会进入当前的函数(如果有函数)。<br>step over将转到当前函数的下一行代码。<br>step out实际上是要跳出当前的函数，让我们回到这个函数。</p>
<p>auto local watch<br>autos和locals基本上只是向你展示局部变量或者来说对你重要的变量。<br>watch从另一方面让我们实际监控变量。<br>我们也可通过菜单栏的Debug-window-memory视图来监控内存。<br><img src="https://s3.bmp.ovh/imgs/2023/01/12/c3c319f24da6d745.png"><br>这个面板我们可以看到地址，地址下的值，以及对应的ascii信息。<br>在vs里，一般来说，在变量没有进行初始化的时候，变量会被会在每个字节赋值上cc(16进制数)，这意味着它是一块未被初始化的堆栈内存。<br>你可以在auto,watch等调试窗口中右键选择十六进制的display。<br>如果需要快速查找某一个变量的地址，可以使用&amp;取地址运算符。<br><img src="https://s3.bmp.ovh/imgs/2023/01/12/fce58b28afcf8695.png"><br>当我们继续运行程序的时候，我们可以看见a在内存中的值发生了改变，变成了程序当中编写的数值。</p>
<p>可以通过设置断点在调试当中跳出循环</p>
<h3 id="cpp的分支与循环"><a href="#cpp的分支与循环" class="headerlink" title="cpp的分支与循环"></a>cpp的分支与循环</h3><p>在设置断点进行调试的时候，可以通过右键某一行进行<strong>反汇编</strong>。<br>当然如果还没有学过汇编就可以试着跳过这一步，，，</p>
<p>nullptr作为一个关键字，用来表示空指针，一般值为0<br>所谓控制流语句，就是break，continue，return之流。</p>
<h3 id="cpp的指针与引用"><a href="#cpp的指针与引用" class="headerlink" title="cpp的指针与引用"></a>cpp的指针与引用</h3><p>当我们说到编程当中最重要的东西，可能是说内存。<br>我们想象内存在计算机中是以一条链的形式表示，外界以逐字节的方式对内存进行访问。<br>cpp的指针本质上并没有类型，所谓的int* ptr只是说我们那个地址的数据可能是我们给它的类型int。同样一个类型不会改变一个指针。指针的类型，决定了它被+1的时候字节走多少个，以及被解引用后该如何进行处理等等。<br>初始化指针可以为NULL &#x3D; 0，NULL无法在内存中被访问，也就是这个指针没有意义，但是在cpp中这样定义是完全可行的，除非你在之后的代码中试图解引用它。<br>指针变量也有自己的地址。</p>
<p>内存的栈区与堆区。<br>下面有一个例子</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span><span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>之后在memory视图当中我们可以看到buffer的头8个字节被赋值为了0。<br>事实上如果使用new来分配内存，数据是被分配在heap上的。我们还应该在使用过后删除这一块内存</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>引用，在计算机处理这个关键字的角度看，基本上和指针是一回事。引用只是基于指针的一种syntax sugar(语法糖)，来使得代码更易读而已。<br>对于指针来说，你可先创建一个指针变量并且给他赋值nullptr或者其他等于0的量，但是引用不能这么做。因为引用变量必须引用一个已经存在的变量，而不是一个新的变量，它们并不真正占用内存。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> ref <span class="token operator">=</span> a<span class="token punctuation">;</span>
ref <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这个时候输出a，a的值就变成2了，我们相当于给a创建了一个别名ref。<br>可以在函数参数中使用<strong>引用传递</strong>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Increment</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> value<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	value<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个时候在外部被传入的原参数也会发生改变。</p>
<p>当你声明一个引用的时候，你必须立刻给它赋值，因为它必须是某物的引用，不能随意进行改变。引用的本质就是常量指针。</p>
<h3 id="cpp当中的类与结构体（真正进入了cpp）"><a href="#cpp当中的类与结构体（真正进入了cpp）" class="headerlink" title="cpp当中的类与结构体（真正进入了cpp）"></a>cpp当中的类与结构体（真正进入了cpp）</h3><p>面向对象编程只是你在编程的时候采用的一种风格关于如何编写你自己的代码。java和c#是面向对象编程的语言，对于这两种语言来说最好不要编写其它风格的程序（虽然事实上可以这样做）<br>但是cpp不同的地方在于它不仅仅支持面向对象编程，还支持面向过程，基于对象，泛型编程这3种。</p>
<p>instance实例化</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Player</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> x <span class="token punctuation">,</span> y<span class="token punctuation">;</span>
	<span class="token keyword">int</span> speed<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	Player player<span class="token punctuation">;</span><span class="token comment">//对象的实例化。</span>
	player<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	player<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	player<span class="token punctuation">.</span>speed <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是如果我们直接进行编译，编译器会报错，告诉我们player对象无法访问类中的私有成员。这是因为有一种东西叫做访问控制。当你创建了一个类的时候你可以指定类中属性的可见性。默认情况下，类中成员的访问控制都是私有的。这意味着只有类内部的函数才能够访问这些变量</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Player</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> x <span class="token punctuation">,</span> y<span class="token punctuation">;</span>
	<span class="token keyword">int</span> speed<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	Player player<span class="token punctuation">;</span><span class="token comment">//对象的实例化。</span>
	player<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	player<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	player<span class="token punctuation">.</span>speed <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过添加public变量，设置变量为公有，这表示我们允许在类的外面访问这些变量。<br>引申到struct，struct的默认访问则是public</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Player</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> x <span class="token punctuation">,</span> y<span class="token punctuation">;</span>
	<span class="token keyword">int</span> speed<span class="token punctuation">;</span>
	
	<span class="token keyword">void</span> <span class="token function">Move</span><span class="token punctuation">(</span><span class="token keyword">int</span> xa <span class="token punctuation">,</span> <span class="token keyword">int</span> ya<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		x <span class="token operator">+=</span> xa <span class="token operator">*</span> speed<span class="token punctuation">;</span>
		y <span class="token operator">+=</span> ya <span class="token operator">*</span> speed<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	Player player<span class="token punctuation">;</span><span class="token comment">//对象的实例化。</span>
	player<span class="token punctuation">.</span><span class="token function">Move</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类内的函数被称为方法(methods)。</p>
<p><strong>用class可以实现的事情，一定也可以通过非class的方式实现</strong></p>
<p><strong>结构体</strong>在cpp中存在主要是因为要保持与c语言的兼容性。使用结构体和类只是个人的代码风格问题，并没有优劣之分</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp</a></div><div class="post_share"><div class="social-share" data-image="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/16/python2/"><img class="prev-cover" src="https://s3.bmp.ovh/imgs/2023/01/12/f8943481ff2f250b.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">python2</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/13/python/"><img class="next-cover" src="https://s3.bmp.ovh/imgs/2023/01/12/1e052378ba7e2bfd.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">python入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/09/CPP%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E3%81%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/" title="CPP标准模板库の打开方式"><img class="cover" src="https://s3.bmp.ovh/imgs/2023/01/12/4bcf264a84775fc0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-09</div><div class="title">CPP标准模板库の打开方式</div></div></a></div><div><a href="/2023/01/12/CPP%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B2/" title="c++与面向对象编程2"><img class="cover" src="https://s3.bmp.ovh/imgs/2023/01/12/1e052378ba7e2bfd.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-12</div><div class="title">c++与面向对象编程2</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/OIP.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">某不知名的作者</div><div class="author-info__description">衬衫的价格是九磅十五便士</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tonzinonin" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E0%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85"><span class="toc-number">1.</span> <span class="toc-text">从0重新开始的c++学习之旅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.0.1.</span> <span class="toc-text">C++的原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpp-compile%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%82"><span class="toc-number">1.0.2.</span> <span class="toc-text">cpp compile的工作原理。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpp%E7%9A%84linking"><span class="toc-number">1.0.3.</span> <span class="toc-text">cpp的linking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpp%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.4.</span> <span class="toc-text">cpp中的变量与函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpp%E5%BD%93%E4%B8%AD%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.5.</span> <span class="toc-text">cpp当中的头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vs%E7%9A%84debug%EF%BC%9A"><span class="toc-number">1.0.6.</span> <span class="toc-text">vs的debug：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpp%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.0.7.</span> <span class="toc-text">cpp的分支与循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpp%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">1.0.8.</span> <span class="toc-text">cpp的指针与引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpp%E5%BD%93%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88%E7%9C%9F%E6%AD%A3%E8%BF%9B%E5%85%A5%E4%BA%86cpp%EF%BC%89"><span class="toc-number">1.0.9.</span> <span class="toc-text">cpp当中的类与结构体（真正进入了cpp）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/12/CPP%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B2/" title="c++与面向对象编程2"><img src="https://s3.bmp.ovh/imgs/2023/01/12/1e052378ba7e2bfd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c++与面向对象编程2"/></a><div class="content"><a class="title" href="/2023/01/12/CPP%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B2/" title="c++与面向对象编程2">c++与面向对象编程2</a><time datetime="2023-01-12T10:26:12.000Z" title="发表于 2023-01-12 18:26:12">2023-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/20/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/" title="基础数论"><img src="https://s3.bmp.ovh/imgs/2023/01/12/e92609f7d9e775f5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础数论"/></a><div class="content"><a class="title" href="/2022/12/20/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/" title="基础数论">基础数论</a><time datetime="2022-12-20T08:30:22.000Z" title="发表于 2022-12-20 16:30:22">2022-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/17/unity%E5%A4%A7%E8%84%91%E5%A4%8D%E5%81%A5/" title="unity大脑复健"><img src="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="unity大脑复健"/></a><div class="content"><a class="title" href="/2022/12/17/unity%E5%A4%A7%E8%84%91%E5%A4%8D%E5%81%A5/" title="unity大脑复健">unity大脑复健</a><time datetime="2022-12-17T12:21:06.000Z" title="发表于 2022-12-17 20:21:06">2022-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/14/KMP/" title="KMP"><img src="https://s3.bmp.ovh/imgs/2023/01/12/b290daacd1b79e32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="KMP"/></a><div class="content"><a class="title" href="/2022/12/14/KMP/" title="KMP">KMP</a><time datetime="2022-12-14T06:21:25.000Z" title="发表于 2022-12-14 14:21:25">2022-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/09/CPP%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E3%81%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/" title="CPP标准模板库の打开方式"><img src="https://s3.bmp.ovh/imgs/2023/01/12/4bcf264a84775fc0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP标准模板库の打开方式"/></a><div class="content"><a class="title" href="/2022/12/09/CPP%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E3%81%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/" title="CPP标准模板库の打开方式">CPP标准模板库の打开方式</a><time datetime="2022-12-09T05:37:16.000Z" title="发表于 2022-12-09 13:37:16">2022-12-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>